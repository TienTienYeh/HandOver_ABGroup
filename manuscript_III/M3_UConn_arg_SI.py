# -*- coding: utf-8 -*-
"""M3_UConn_E_arg_I_arg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eko4f29jxpmfPyyTE0WHsAJluPe-Ihaf
"""

## Current cases:
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--E", type=float, help="E0i")
parser.add_argument("--I", type=float, help="current_amp")
args = parser.parse_args()

E0i = args.E
current_amp = args.I

print(f"E0i is {args.E}, and current is {args.I}")

import numpy as np

w_input_set = 2*np.pi / 40
solve_time = 500
t_on, t_off, time_evolute = [0, solve_time, True]
mesh_size = 4
figsize = (5,3)

"""# Simulation of Laguerre-Gaussian beam on superconductors
- Edit by TTYeh (20250415) <br>

### Load function
The following codes work for both Colab environment and tdgl environment (Installation: https://py-tdgl.readthedocs.io/en/latest/) <br>
This section is for loading the revised functions (originally from Logan's code).
"""

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_formats = {"retina", "png"}
Execute_GPU = True

import os
os.environ["OPENBLAS_NUM_THREADS"] = "1"
import matplotlib.pyplot as plt
import numpy as np

plt.rcParams["figure.figsize"] = (7.5, 2.5)

import tdgl
# from tdgl.geometry import box, circle
# from tdgl.visualization.animate import create_animation
tdgl.SolverOptions.gpu = Execute_GPU # !!! Turn on GPU calculation !!!
from IPython.display import HTML, display
import h5py

import logging
import os
import shutil
from contextlib import nullcontext
from logging import Logger
from typing import Any, Dict, Literal, Optional, Sequence, Tuple, Union

from matplotlib import animation
from matplotlib import pyplot as plt
from tqdm import tqdm

from tdgl.device.device import Device
from tdgl.solution.data import get_data_range
from tdgl.visualization.common import DEFAULT_QUANTITIES, PLOT_DEFAULTS, Quantity, auto_grid
from tdgl.visualization.io import get_plot_data, get_state_string

def delete_files_in_directory(directory_path):
   try:
     files = os.listdir(directory_path)
     for file in files:
       file_path = os.path.join(directory_path, file)
       if os.path.isfile(file_path):
         os.remove(file_path)
     print("All files deleted successfully.")
   except OSError:
     print("Error occurred while deleting files.")

def create_animation_withEMwave(
    input_file: Union[str, h5py.File],
    *,
    output_file: Optional[str] = None,
    quantities: Union[str, Sequence[str]] = DEFAULT_QUANTITIES,
    shading: Literal["flat", "gouraud"] = "gouraud",
    fps: int = 30,
    dpi: float = 100,
    max_cols: int = 6,
    min_frame: int = 0,
    max_frame: int = -1,
    autoscale: bool = False,
    dimensionless: bool = False,
    xlim: Optional[Tuple[float, float]] = None,
    ylim: Optional[Tuple[float, float]] = None,
    axis_labels: bool = False,
    axes_off: bool = False,
    title_off: bool = False,
    full_title: bool = True,
    logger: Optional[Logger] = None,
    figure_kwargs: Optional[Dict[str, Any]] = None,
    writer: Union[str, animation.MovieWriter, None] = None,
    quiver_scale = 10,
    quiver_mesh_n = 20,
    width_quiver = 0.01,
) -> animation.FuncAnimation:
    """Generates, and optionally saves, and animation of a TDGL simulation.

    Args:
        input_file: An open h5py file or a path to an H5 file containing
            the :class:`tdgl.Solution` you would like to animate.
        output_file: A path to which to save the animation,
            e.g., as a gif or mp4 video.
        quantities: The names of the quantities to animate.
        shading: Shading method, "flat" or "gouraud". See matplotlib.pyplot.tripcolor.
        fps: Frame rate in frames per second.
        dpi: Resolution in dots per inch.
        max_cols: The maxiumum number of columns in the subplot grid.
        min_frame: The first frame of the animation.
        max_frame: The last frame of the animation.
        autoscale: Autoscale colorbar limits at each frame.
        dimensionless: Use dimensionless units for axes
        xlim: x-axis limits
        ylim: y-axis limits
        axes_off: Turn off the axes for each subplot.
        title_off: Turn off the figure suptitle.
        full_title: Include the full "state" for each frame in the figure suptitle.
        figure_kwargs: Keyword arguments passed to ``plt.subplots()`` when creating
            the figure.
        writer: A :class:`matplotlib.animation.MovieWriter` instance to use when
            saving the animation.
        logger: A logger instance to use.

    Returns:
        The animation as a :class:`matplotlib.animation.FuncAnimation`.
    """
    writer = animation.FFMpegWriter()

    if isinstance(input_file, str):
        input_file = input_file
    if quantities is None:
        quantities = Quantity.get_keys()
    if isinstance(quantities, str):
        quantities = [quantities]
    quantities = [Quantity.from_key(name.upper()) for name in quantities]
    num_plots = len(quantities) +2 # Add two more subplots for E, Bz
    logger = logger or logging.getLogger()
    figure_kwargs = figure_kwargs or dict()
    figure_kwargs.setdefault("constrained_layout", True)
    default_figsize = (
        3.25 * min(max_cols, num_plots),
        2.5 * max(1, num_plots // max_cols),
    )
    figure_kwargs.setdefault("figsize", default_figsize)
    figure_kwargs.setdefault("sharex", True)
    figure_kwargs.setdefault("sharey", True)

    logger.info(f"Creating animation for {[obs.name for obs in quantities]!r}.")

    mpl_context = nullcontext() if output_file is None else plt.ioff()
    if isinstance(input_file, str):
        h5_context = h5py.File(input_file, "r")
    else:
        h5_context = nullcontext(input_file)

    with h5_context as h5file:
        with mpl_context:
            device = Device.from_hdf5(h5file["solution/device"])
            mesh = device.mesh
            if dimensionless:
                scale = 1
                units_str = "\\xi"
            else:
                scale = device.layer.coherence_length
                units_str = f"{device.ureg(device.length_units).units:~L}"
            x, y = scale * mesh.sites.T

            # Get the ranges for the frame
            _min_frame, _max_frame = get_data_range(h5file)
            min_frame = max(min_frame, _min_frame)
            if max_frame == -1:
                max_frame = _max_frame
            else:
                max_frame = min(max_frame, _max_frame)

            # Temp data to use in plots
            temp_value = np.ones(len(mesh.sites), dtype=float)
            temp_value[0] = 0
            temp_value[1] = 0.5

            fig, axes = auto_grid(num_plots, max_cols=max_cols, **figure_kwargs)
            collections = []
            quantities.append('E') # Add one more quantities
            quantities.append('Bz') # Add one more quantities
            X = np.linspace(-width/2,width/2,quiver_mesh_n)
            Y = np.linspace(-height/2,height/2,quiver_mesh_n)
            Xv, Yv = np.meshgrid(X, Y)
            ti = dict(input_file['data'][str(1)].attrs)['time']
            E_x, E_y = E_input_frame(Xv,Yv,ti,take_real=False)
            B_x, B_y, B_z = E2Bv(Xv,Yv,E0i*E_x,E0i*E_y,constant_Bz,c,w_input)
            Bzmax, Bzmin = [find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input), -find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input)]

            for quantity, ax in zip(quantities, axes.flat):
                ax: plt.Axes
                if quantity!='E' and quantity!='Bz':
                    opts = PLOT_DEFAULTS[quantity]
                    collection = ax.tripcolor(
                        x,
                        y,
                        temp_value,
                        triangles=mesh.elements,
                        shading=shading,
                        cmap=opts.cmap,
                        vmin=opts.vmin,
                        vmax=opts.vmax,
                    )
                    cbar = fig.colorbar(collection, ax=ax)
                    cbar.set_label(opts.clabel)
                    ax.set_aspect("equal")
                    ax.set_title(quantity.value)
                    ax.set_xlim(xlim)
                    ax.set_ylim(ylim)
                    if axes_off:
                        ax.axis("off")
                    if axis_labels:
                        ax.set_xlabel(f"$x$ [${units_str}$]")
                        ax.set_ylabel(f"$y$ [${units_str}$]")
                    collections.append(collection)

                if quantity=='E': # For new plot: "E"
                    collection = ax.quiver(
                        Xv,
                        Yv,
                        np.real(E_x),
                        np.real(E_y),
                        scale=quiver_scale,
                        scale_units='x',
                        width=width_quiver*abs(X[2]-X[1]),
                    )
                    ax.set_aspect("equal")
                    ax.set_title('$E$')
                    ax.set_xlim(xlim)
                    ax.set_ylim(ylim)
                    if axes_off:
                        ax.axis("off")
                    if axis_labels:
                        ax.set_xlabel(f"$x$ [${units_str}$]")
                        ax.set_ylabel(f"$y$ [${units_str}$]")
                    collections.append(collection)
                if quantity=='Bz': # For new plot: "Bz"
                    collection = ax.pcolormesh(
                        X,
                        Y,
                        np.real(B_z),
                        cmap="PRGn",
                        shading='gouraud',
                        vmin=Bzmin,
                        vmax=Bzmax,
                    )
                    cbar = plt.colorbar(collection)
                    cbar.set_label('$B_{z}$ ['+field_units+']')
                    ax.set_aspect("equal")
                    ax.set_title('$B_{z}$ ')
                    ax.set_xlim(xlim)
                    ax.set_ylim(ylim)
                    if axes_off:
                        ax.axis("off")
                    if axis_labels:
                        ax.set_xlabel(f"$x$ [${units_str}$]")
                        ax.set_ylabel(f"$y$ [${units_str}$]")
                    collections.append(collection)
            vmins = [+np.inf for _ in quantities]
            vmaxs = [-np.inf for _ in quantities]

            def update(frame):
                if not h5file:
                    return
                frame += min_frame
                state = get_state_string(h5file, frame, max_frame)
                if not full_title:
                    state = state.split(",")[0]
                if not title_off:
                    fig.suptitle(state)

                ti = dict(input_file['data'][str(frame)].attrs)['time']
                E_x, E_y = E_input_frame(Xv,Yv,ti,take_real=False)
                B_x, B_y, B_z = E2Bv(Xv,Yv,E0i*E_x,E0i*E_y,constant_Bz,c,w_input)

                for i, (quantity, collection) in enumerate(
                    zip(quantities, collections)
                ):
                    if quantity!='E' and quantity!='Bz':
                        opts = PLOT_DEFAULTS[quantity]
                        values, direction, _ = get_plot_data(h5file, mesh, quantity, frame)
                        mask = np.abs(values - np.mean(values)) <= 6 * np.std(values)
                        if opts.vmin is None:
                            if autoscale:
                                vmins[i] = np.min(values[mask])
                            else:
                                vmins[i] = min(vmins[i], np.min(values[mask]))
                        else:
                            vmins[i] = opts.vmin
                        if opts.vmax is None:
                            if autoscale:
                                vmaxs[i] = np.max(values[mask])
                            else:
                                vmaxs[i] = max(vmaxs[i], np.max(values[mask]))
                        else:
                            vmaxs[i] = opts.vmax
                        if opts.symmetric:
                            vmax = max(abs(vmins[i]), abs(vmaxs[i]))
                            vmaxs[i] = vmax
                            vmins[i] = -vmax
                        if shading == "flat":
                            # https://stackoverflow.com/questions/40492511/set-array-in-tripcolor-bug
                            values = values[mesh.elements].mean(axis=1)
                        collection.set_array(values)
                        collection.set_clim(vmins[i], vmaxs[i])
                    if quantity=='E':
                        collection.set_UVC(np.real(E_x),np.real(E_y))
                    if quantity=='Bz':
                        collection.set_array(np.real(B_z))
                        collection.set_clim(Bzmin, Bzmax)
                fig.canvas.draw()

            anim = animation.FuncAnimation(
                fig,
                update,
                frames=max_frame - min_frame,
                interval=1e3 / fps,
                blit=False,
            )

        if output_file is not None:
            output_file = os.path.join(os.getcwd(), output_file)
            if writer is None:
                kwargs = dict(fps=fps)
            else:
                kwargs = dict(writer=writer)
            fname = os.path.basename(output_file)
            with tqdm(
                total=len(range(min_frame, max_frame)),
                unit="frames",
                desc=f"Saving to {fname}",
            ) as pbar:
                anim.save(
                    output_file,
                    dpi=dpi,
                    progress_callback=lambda frame, total: pbar.update(1),
                    **kwargs,
                )

        return anim

def make_video_from_solution(
    solution,
    quantities=("order_parameter", "phase"),
    fps=20,
    figsize=(5, 4),
    output_file='None',
    dpi=100,
    quiver_scale=10,
    quiver_mesh_n=20,
    width_quiver=0.01,
    writer=None,
):
    """Generates an HTML5 video from a tdgl.Solution."""

    with tdgl.non_gui_backend():
        with h5py.File(solution.path, "r") as h5file:
            anim = create_animation_withEMwave(
                h5file,
                quantities=quantities,
                fps=fps,
                figure_kwargs=dict(figsize=figsize),
                axis_labels = True,
                output_file=output_file,
                dpi=dpi,
                quiver_scale=quiver_scale,
                quiver_mesh_n=quiver_mesh_n,
                width_quiver=width_quiver,
                writer=writer,
            )
            video = anim.to_html5_video()
        return HTML(video)

MAKE_ANIMATIONS = True
# MAKE_ANIMATIONS = False
""" Done."""

"""#### Light source: Laguerre-Gaussian Beam
New part for time-dependent guage vector potential, including...
1. $E$ and $A$ of Laguerre-Gaussian Beam
2. Relevant tools
<!-- - Ref: http://kirkmcd.princeton.edu/examples/axicon_big.pdf <by> -->
"""

### LG beam

from scipy.special import genlaguerre
import scipy.constants as cons
from tdgl.parameter import Parameter
import pint # https://pint.readthedocs.io/en/0.10.1/tutorial.html

def uniform_Bz_vector_potential(
    positions: np.ndarray,
    Bz: Union[float, str, pint.Quantity],
) -> np.ndarray:
    """Calculates the magnetic vector potential [Ax, Ay, Az] at ``positions``
    due uniform magnetic field along the z-axis with strength ``Bz``.

    Args:
        positions: Shape (n, 3) array of (x, y, z) positions in meters at which to
            evaluate the vector potential.
        Bz: The strength of the uniform field, as a pint-parseable string,
            a pint.Quantity, or a float with units of Tesla.

    Returns:
        Shape (n, 3) array of the vector potential [Ax, Ay, Az] at ``positions``
        in units of Tesla * meter.
    """
    # assert isinstance(Bz, (float, str, pint.Quantity)), type(Bz)
    positions = np.atleast_2d(positions)
    # assert positions.shape[1] == 3, positions.shape
    # if not isinstance(positions, pint.Quantity):
    #     positions = positions * ureg("meter")
    # if isinstance(Bz, str):
    #     Bz = ureg(Bz)
    # if isinstance(Bz, float):
    #     Bz = Bz * ureg("tesla")
    xs = positions[:, 0]
    ys = positions[:, 1]
    dx = np.ptp(xs)
    dy = np.ptp(ys)
    xs = xs - (xs.min() + dx / 2)
    ys = ys - (ys.min() + dy / 2)
    Ax = -Bz * ys / 2
    Ay = Bz * xs / 2
    A = np.stack([Ax, Ay, np.zeros_like(Ax)], axis=1)
    return A

def constant_field_vector_potential(
    x,
    y,
    z,
    *,
    Bz: float,
    field_units: str = "mT",
    length_units: str = "um",
):
    if z.ndim == 0:
        z = z * np.ones_like(x)
    positions = np.array([x.squeeze(), y.squeeze(), z.squeeze()]).T
    # Bz = Bz * ureg(field_units)
    A = uniform_Bz_vector_potential(positions, Bz)
    return A

def findval(X,x_value):
    return np.argmin(abs(X-x_value))

def Cpl(p,l):
  if abs(p)==0: p=1
  factorial_p = 1
  factorial_pl = 1
  for i in range(abs(p)): factorial_p = factorial_p*(i+1)
  for i in range(abs(p)+abs(l)): factorial_pl = factorial_pl*(i+1)
  return np.sqrt(2*factorial_p/np.pi/factorial_pl)

### ------------------------------------------------------------------------------------------ ###

### A of LG beam (equip the functions of "Step structured Bz" and "constant uniform Bz")

def A_LG_t(x, y, z, *, t,
                   w: float = 1.0,
                   E0: float = 1.0,
                   w0: float = 1.0,
                   xc_Gauss: float = 0.0,
                   yc_Gauss: float = 0.0,
                   z0: float = 0.0,
                   n: float = 1.0,
                   phi0_t: float = 0,
                   phi0_xy: float = 0,
                   tau: float = 1.0,
                   p: float = 0.0,
                   l: float = 0.0,
                   s: float = 0.0,
                   c: float = 1.0,
                   t_on: float = 0.0,
                   t_off: float = 1.0,
                   Bz: float = 0,
                   polarization_modulation: bool = False,
                   polarization: str = 'none',
                   angular_freq_units: str = "THz",
                   length_units: str = "um",
                   field_units: str = "mT",
                   E_field_units: str = "newton / coulomb",
                   time_units: str = "ps",
                   take_complex=False,
                   time_evolute: bool = True,

):
    """ Vector potential of Laguerre-Gaussian beam of p-th degree of mode and l-th order of mode
    From E to A, A = -iE/w
    """
    X = (x-xc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of x-axis [um]
    Y = (y-yc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of y-axis [um]
    Z = (z-z0) * 1 # ureg(length_units)).to("m").magnitude   # mesh of y-axis [um]
    w0 = w0 * 1 # ureg(length_units) .to("m").magnitude   # Beam waist (suppose w0_x =w0_y) [um]
    k = w/c   # Wavenumber
    ti = np.copy(t)#(t * ureg(time_units)).to("s").magnitude   # Input time
    # E0 = (E0 * ureg(E_field_units)).to("newton / coulomb").magnitude   # Electrical field |E0|
    zR = n*k*w0**2/2   # Rayleigh length, n: refractive index
    wz = w0 * np.sqrt(1+(Z/zR)**2)   # Spot radius
    zeta = Z/zR

    r = np.sqrt(X**2+Y**2)   # Radius
    phi = np.angle(X+1j*Y)   # Azimuthal angle
    if polarization.lower()=='x' or polarization.lower()=='linear x': s, phi0_xy = [0.0,0.0]
    if polarization.lower()=='y' or polarization.lower()=='linear y': s, phi0_xy = [0.0,np.pi/2]
    if polarization.lower()=='lc' or polarization.lower()=='left circular': s, phi0_xy = [1,np.pi/4]
    if polarization.lower()=='rc' or polarization.lower()=='right circular': s, phi0_xy = [-1,np.pi/4]
    phi_t = np.copy(phi0_t) # !!!!!! ONLY CONSTANT PHASE REMAINS !!!!!!
    if time_evolute: phi_t = phi_t + w*ti
    phiGouy = (2*p+np.abs(l)+1)*np.arctan(Z/zR) # Gouy phase
    u = E0 * 1 * (np.sqrt(2)*r/wz)**l * genlaguerre(p,l)(2*r**2/wz**2) * w0/wz * np.exp(-1j*phiGouy +1j*(l*phi +k*z +k*r**2/2/(z-1j*zR)))

    if t>t_off or t<t_on: t_step = 0
    else: t_step = 1

    pol_m_x, pol_m_y = [np.cos(phi0_xy),np.sin(phi0_xy)]
    if polarization_modulation: pol_m_x, pol_m_y = (np.abs([np.cos(l*phi+phi0_xy), np.sin(l*phi+phi0_xy)]))
    Ex = u * np.exp(-1j*(phi_t)) * pol_m_x * t_step
    Ey = u * np.exp(-1j*(phi_t+s*np.pi/2)) * pol_m_y * t_step

    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Az = np.zeros_like(Ax)
    Ax[np.isnan(Ax)] = 0
    Ax[np.isinf(Ax)] = 0
    Ay[np.isnan(Ay)] = 0
    Ay[np.isinf(Ay)] = 0
    A_constBz = constant_field_vector_potential(x, y, z, Bz=Bz, field_units=field_units, length_units=length_units)
    A = np.stack([np.real(Ax), np.real(Ay), np.real(Az)], axis=1) #+ A_constBz
    if take_complex: A = np.stack([(Ax), (Ay), (Az)], axis=1) #+ A_constBz
    # A = np.array([np.real(Ax), np.real(Ay), np.real(Az)]).T
    return A#.to(f"{field_units} * {length_units}").magnitude

# callable(A_LG_t_xy)

def A_LG(*,
        w: float = 1.0,
        E0: float = 1.0,
        w0: float = 1.0,
        xc_Gauss: float = 0.0,
        yc_Gauss: float = 0.0,
        z0: float = 0.0,
        n: float = 1.0,
        phi0_t: float = 0,
        phi0_xy: float = 0,
        tau: float = 1.0,
        c: float = 1.0,
        p: float = 0.0,
        l: float = 0.0,
        s: float = 0.0,
        t_on: float = 0.0,
        t_off: float = 1.0,
        Bz: float = 0,
        polarization_modulation: bool = False,
        polarization: str = 'none',
        angular_freq_units: str = "THz",
        length_units: str = "um",
        E_field_units: str = "newton / coulomb",
        field_units: str = "mT",
        time_units: str = "ps",
        time_evolute: bool = True,
        time_dependent=True,
)-> Parameter:
    """Vector potential of Laguerre-Gaussian beam  LG(p)(l)
    # for linear polarization, LG00, phi0_xy could be any number and s=0
    # for Circular polarization, LG00, phi0_xy=pi/4 and s=+-1
    # for linear polarization, LG01, phi0_xy could be any number and s=0
    # for Circular polarization, LG01, phi0_xy=pi/4 and s=+-1
    # for Radial polarization, LG01, s=+1, phi0_xy=0, polarization_modulation = True
    # for Azimuthal polarization, LG01, s=+1, phi0_xy=np.pi/2, polarization_modulation = True

    Equip the function "Step structured Bz" and "constant uniform Bz"
    # Step structured Bz:
        # Step time: t_on, t_off, time_evolute = [t_on, t_off, False]
        # Continuous case: t_on, t_off, time_evolute = [0, solve_time, True]
    # constant Bz:
        # Bz = Bz

    Note of useful relation: f=w/2p, c=fL, k=2p/L, k=w/c, 1/w=1/kc=L/2pc

    Args:
        w: angular frequency ( w = 2 pi f ) ,
        k_dir: prapagation direction
        E0: amplitude of electrical field
        phi0_t: initial phase of time
        phi0_xy: initial angle of xy plane azimuthal angle
        tau: Unit time (SC dissipation time)
        p: Degree of mode
        l: Order of mode, or orbital angular momentum of LG beam
        s: spin angular momentum of LG beam
    Returns:
        A :class:`tdgl.Parameter` that produces a linear ramp.
    """
    return Parameter(
        A_LG_t,
        w=w,
        w0=w0,
        E0=E0i,
        phi0_t=phi0_t,
        phi0_xy=phi0_xy,
        xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
        p=p, l=l, s=s, c=c, Bz=Bz, z0=z0, n=n,
        tau=tau, t_on=t_on, t_off=t_off,
        polarization=polarization,
        polarization_modulation=polarization_modulation,
        angular_freq_units=angular_freq_units,
        length_units=length_units,
        E_field_units=E_field_units,
        field_units=field_units,
        time_units=time_units,
        time_evolute=time_evolute,
        time_dependent=True,
    )


### ------------------------------------------------------------------------------------------ ###

### A of LG beam on GPU (cupy)

# import cupy as cp

# def uniform_Bz_vector_potential_cupy(
#     positions: np.ndarray,
#     Bz: Union[float, str, pint.Quantity],
# ) -> cp.ndarray:
#     """Calculates the magnetic vector potential [Ax, Ay, Az] at ``positions``
#     due uniform magnetic field along the z-axis with strength ``Bz``.

#     Args:
#         positions: Shape (n, 3) array of (x, y, z) positions in meters at which to
#             evaluate the vector potential.
#         Bz: The strength of the uniform field, as a pint-parseable string,
#             a pint.Quantity, or a float with units of Tesla.

#     Returns:
#         Shape (n, 3) array of the vector potential [Ax, Ay, Az] at ``positions``
#         in units of Tesla * meter.
#     """
#     # assert isinstance(Bz, (float, str, pint.Quantity)), type(Bz)
#     positions = cp.atleast_2d(positions)
#     # assert positions.shape[1] == 3, positions.shape
#     # if not isinstance(positions, pint.Quantity):
#     #     positions = positions * ureg("meter")
#     # if isinstance(Bz, str):
#     #     Bz = ureg(Bz)
#     # if isinstance(Bz, float):
#     #     Bz = Bz * ureg("tesla")
#     xs = cp.array(positions[:, 0])
#     ys = cp.array(positions[:, 1])
#     dx = cp.ptp(xs)
#     dy = cp.ptp(ys)
#     xs = xs - (xs.min() + dx / 2)
#     ys = ys - (ys.min() + dy / 2)
#     Ax = -Bz * ys / 2
#     Ay = Bz * xs / 2
#     A = cp.stack([Ax, Ay, np.zeros_like(Ax)], axis=1)
#     return A

# def constant_field_vector_potential_cupy(
#     x,
#     y,
#     z,
#     *,
#     Bz: float,
#     field_units: str = "mT",
#     length_units: str = "um",
# ):
#     if z.ndim == 0:
#         z = z * cp.ones_like(x)
#     positions = cp.array([x.squeeze(), y.squeeze(), z.squeeze()]).T
#     # Bz = Bz * ureg(field_units)
#     A = uniform_Bz_vector_potential_cupy(positions, Bz)
#     return A

def A_LG_t_cupy(x, y, z, *, t,
                   w: float = 1.0,
                   E0: float = 1.0,
                   w0: float = 1.0,
                   xc_Gauss: float = 0.0,
                   yc_Gauss: float = 0.0,
                   z0: float = 0.0,
                   n: float = 1.0,
                   phi0_t: float = 0,
                   phi0_xy: float = 0,
                   tau: float = 1.0,
                   p: float = 0.0,
                   l: float = 0.0,
                   s: float = 0.0,
                   c: float = 1.0,
                   t_on: float = 0.0,
                   t_off: float = 1.0,
                   Bz: float = 0,
                   polarization_modulation: bool = False,
                   polarization: str = 'none',
                   angular_freq_units: str = "THz",
                   length_units: str = "um",
                   field_units: str = "mT",
                   E_field_units: str = "newton / coulomb",
                   time_units: str = "ps",
                   take_complex=False,
                   time_evolute: bool = True,

):
    """ Vector potential of Laguerre-Gaussian beam of p-th degree of mode and l-th order of mode
    From E to A, A = -iE/w
    """
    X = cp.array(x-xc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of x-axis [um]
    Y = cp.array(y-yc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of y-axis [um]
    Z = cp.array(z-z0) * 1 # ureg(length_units)).to("m").magnitude   # mesh of y-axis [um]
    w0 = w0 * 1 # ureg(length_units) .to("m").magnitude   # Beam waist (suppose w0_x =w0_y) [um]
    k = w/c   # Wavenumber
    ti = (t)#(t * ureg(time_units)).to("s").magnitude   # Input time
    # E0 = (E0 * ureg(E_field_units)).to("newton / coulomb").magnitude   # Electrical field |E0|
    # print(ti)
    zR = cp.array(n*k*w0**2/2)   # Rayleigh length, n: refractive index
    # print(zR)
    # print(w0)
    wz = cp.array(w0 * cp.sqrt(1+(Z/zR)**2))   # Spot radius
    zeta = cp.array(Z/zR)

    r = cp.sqrt(X**2+Y**2)   # Radius
    phi = cp.angle(X+1j*Y)   # Azimuthal angle
    if polarization.lower()=='x' or polarization.lower()=='linear x': s, phi0_xy = [0.0,0.0]
    if polarization.lower()=='y' or polarization.lower()=='linear y': s, phi0_xy = [0.0,np.pi/2]
    if polarization.lower()=='lc' or polarization.lower()=='left circular': s, phi0_xy = [1,np.pi/4]
    if polarization.lower()=='rc' or polarization.lower()=='right circular': s, phi0_xy = [-1,np.pi/4]
    phi_t = (phi0_t) # !!!!!! ONLY CONSTANT PHASE REMAINS !!!!!!
    if time_evolute: phi_t = phi_t + w*ti
    phiGouy = cp.array((2*p+cp.abs(l)+1)*cp.arctan(Z/zR)) # Gouy phase
    # genlaguerre: https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html
    # u = E0 * Cpl(p,l)/w0 * (cp.sqrt(2)*r/(wz))**l * cp.array(genlaguerre(p,l)(2*np.array(r**2)/np.array(wz**2))) * w0/wz * cp.exp( -1j*phiGouy +1j*(l*phi +k*Z +k*r**2/2/(Z-1j*zR)))
    u = E0 * 1 * (cp.sqrt(2)*r/(wz))**l * 1 * w0/wz * cp.exp(-1j*phiGouy +1j*(l*phi +k*Z +k*r**2/2/(Z-1j*zR)))
    if t>t_off or t<t_on: t_step = 0
    else: t_step = 1

    pol_m_x, pol_m_y = [cp.cos(phi0_xy),cp.sin(phi0_xy)]
    if polarization_modulation: pol_m_x, pol_m_y = (cp.abs([cp.cos(l*phi+phi0_xy), cp.sin(l*phi+phi0_xy)]))
    Ex = u * cp.exp(-1j*(phi_t)) * pol_m_x * t_step
    Ey = u * cp.exp(-1j*(phi_t+s*cp.pi/2)) * pol_m_y * t_step

    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Az = cp.zeros_like(Ax)
    Ax[np.isnan(Ax)] = 0
    Ax[np.isinf(Ax)] = 0
    Ay[np.isnan(Ay)] = 0
    Ay[np.isinf(Ay)] = 0
    A_constBz = 0#constant_field_vector_potential_cupy(x, y, z, Bz=Bz, field_units=field_units, length_units=length_units)
    A = cp.stack([cp.real(Ax), cp.real(Ay), cp.real(Az)], axis=1) # + A_constBz
    if take_complex: A = cp.stack([(Ax), (Ay), (Az)], axis=1) # + A_constBz
    # A = np.array([np.real(Ax), np.real(Ay), np.real(Az)]).T
    return cp.asnumpy(A)#.to(f"{field_units} * {length_units}").magnitude

def A_LG_cupy(*,
        w: float = 1.0,
        E0: float = 1.0,
        w0: float = 1.0,
        xc_Gauss: float = 0.0,
        yc_Gauss: float = 0.0,
        z0: float = 0.0,
        n: float = 1.0,
        phi0_t: float = 0,
        phi0_xy: float = 0,
        tau: float = 1.0,
        c: float = 1.0,
        p: float = 0.0,
        l: float = 0.0,
        s: float = 0.0,
        t_on: float = 0.0,
        t_off: float = 1.0,
        Bz: float = 0,
        polarization_modulation: bool = False,
        polarization: str = 'none',
        angular_freq_units: str = "THz",
        length_units: str = "um",
        E_field_units: str = "newton / coulomb",
        field_units: str = "mT",
        time_units: str = "ps",
        time_evolute: bool = True,
        time_dependent=True,
)-> Parameter:
    """Vector potential of Laguerre-Gaussian beam  LG(p)(l)
    # for linear polarization, LG00, phi0_xy could be any number and s=0
    # for Circular polarization, LG00, phi0_xy=pi/4 and s=+-1
    # for linear polarization, LG01, phi0_xy could be any number and s=0
    # for Circular polarization, LG01, phi0_xy=pi/4 and s=+-1
    # for Radial polarization, LG01, s=+1, phi0_xy=0, polarization_modulation = True
    # for Azimuthal polarization, LG01, s=+1, phi0_xy=np.pi/2, polarization_modulation = True

    Equip the function "Step structured Bz" and "constant uniform Bz"
    # Step structured Bz:
        # Step time: t_on, t_off, time_evolute = [t_on, t_off, False]
        # Continuous case: t_on, t_off, time_evolute = [0, solve_time, True]
    # constant Bz:
        # Bz = Bz

    Note of useful relation: f=w/2p, c=fL, k=2p/L, k=w/c, 1/w=1/kc=L/2pc

    Args:
        w: angular frequency ( w = 2 pi f ) ,
        k_dir: prapagation direction
        E0: amplitude of electrical field
        phi0_t: initial phase of time
        phi0_xy: initial angle of xy plane azimuthal angle
        tau: Unit time (SC dissipation time)
        p: Degree of mode
        l: Order of mode, or orbital angular momentum of LG beam
        s: spin angular momentum of LG beam
    Returns:
        A :class:`tdgl.Parameter` that produces a linear ramp.
    """
    return Parameter(
        A_LG_t_cupy,
        w=w,
        w0=w0,
        E0=E0i,
        phi0_t=phi0_t,
        phi0_xy=phi0_xy,
        xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
        p=p, l=l, s=s, c=c, Bz=Bz, z0=z0, n=n,
        tau=tau, t_on=t_on, t_off=t_off,
        polarization=polarization,
        polarization_modulation=polarization_modulation,
        angular_freq_units=angular_freq_units,
        length_units=length_units,
        E_field_units=E_field_units,
        field_units=field_units,
        time_units=time_units,
        time_evolute=time_evolute,
        time_dependent=True,
    )


### ------------------------------------------------------------------------------------------ ###

### Bz component

# B = curl(A) = (dyAz - dzAy) ex + (dzAx - dxAz) ey + (dxAy - dyAx) ez
def A2B(x, y, z, A):

    ''' Calculate magnetic field B from vector potential A
    return B
    '''
    B.x = np.diff(A[:,2])/np.diff(y) - np.diff(A[:,1])/np.diff(z)
    B.y = np.diff(A[:,0])/np.diff(z) - np.diff(A[:,2])/np.diff(x)
    B.z = np.diff(A[:,1])/np.diff(x) - np.diff(A[:,0])/np.diff(y)
    return B

def E_LG_t(x, y, z, *, t,
                   w: float = 1.0,
                   E0: float = 1.0,
                   w0: float = 1.0,
                   xc_Gauss: float = 0.0,
                   yc_Gauss: float = 0.0,
                   z0: float = 0.0,
                   n: float = 1.0,
                   phi0_t: float = 0,
                   phi0_xy: float = 0,
                   tau: float = 1.0,
                   p: float = 0.0,
                   l: float = 0.0,
                   s: float = 0.0,
                   c: float = 1.0,
                   t_on: float = 0.0,
                   t_off: float = 1.0,
                   Bz: float = 0,
                   polarization_modulation: bool = False,
                   polarization: str = 'none',
                   angular_freq_units: str = "THz",
                   length_units: str = "um",
                   field_units: str = "mT",
                   E_field_units: str = "newton / coulomb",
                   time_units: str = "ps",
                   time_evolute: bool = True,

):
    """ Electric field x, y of Laguerre-Gaussian beam of p-th degree of mode and l-th order of mode
    From E to A, A = -iE/w
    """
    X = (x-xc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of x-axis [um]
    Y = (y-yc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of y-axis [um]
    Z = (z-z0) * 1 # ureg(length_units)).to("m").magnitude   # mesh of y-axis [um]
    w0 = w0 * 1 # ureg(length_units) .to("m").magnitude   # Beam waist (suppose w0_x =w0_y) [um]
    k = w/c   # Wavenumber
    ti = np.copy(t)#(t * ureg(time_units)).to("s").magnitude   # Input time
    # E0 = (E0 * ureg(E_field_units)).to("newton / coulomb").magnitude   # Electrical field |E0|
    zR = (n*k*w0**2/2)   # Rayleigh length, n: refractive index
    wz = w0 * np.sqrt(1+(Z/zR)**2)   # Spot radius
    zeta = Z/zR

    r = np.sqrt(X**2+Y**2)   # Radius
    phi = np.angle(X+1j*Y)   # Azimuthal angle
    if polarization.lower()=='x' or polarization.lower()=='linear x': s, phi0_xy = [0.0,0.0]
    if polarization.lower()=='y' or polarization.lower()=='linear y': s, phi0_xy = [0.0,np.pi/2]
    if polarization.lower()=='lc' or polarization.lower()=='left circular': s, phi0_xy = [1,np.pi/4]
    if polarization.lower()=='rc' or polarization.lower()=='right circular': s, phi0_xy = [-1,np.pi/4]
    phi_t = np.copy(phi0_t) # !!!!!! ONLY CONSTANT PHASE REMAINS !!!!!!
    if time_evolute: phi_t = phi_t + w*ti
    phiGouy = (2*p+np.abs(l)+1)*np.arctan(Z/zR) # Gouy phase
    u = E0 * 1 * (np.sqrt(2)*r/wz)**l * genlaguerre(p,l)(2*r**2/wz**2) * w0/wz * np.exp(-1j*phiGouy +1j*(l*phi +k*z +k*r**2/2/(z-1j*zR)))

    if t>t_off or t<t_on: t_step = 0
    else: t_step = 1

    pol_m_x, pol_m_y = [np.cos(phi0_xy),np.sin(phi0_xy)]
    if polarization_modulation: pol_m_x, pol_m_y = (np.abs([np.cos(l*phi+phi0_xy), np.sin(l*phi+phi0_xy)]))
    Ex = u * np.exp(-1j*(phi_t)) * pol_m_x * t_step
    Ey = u * np.exp(-1j*(phi_t+s*np.pi/2)) * pol_m_y * t_step
    Ez = np.zeros_like(Ex)
    return Ex, Ey, Ez

def E2B(x,y,Ex,Ey,Bz_constant,c,w):
    By = Ex/c
    Bx = -Ey/c
    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Bz_A = np.zeros_like(By)
    Bz_A[1:] = np.diff(Ay)/np.diff(x) - np.diff(Ax)/np.diff(y)
    Bz = Bz_A + Bz_constant
    # B = np.stack([np.real(Bx), np.real(By), np.real(Bz)], axis=1)
    return Bx, By, Bz #.to(f"{field_units}").magnitude

def E2Bv(xv,yv,Ex,Ey,Bz_constant,c,w):
    By = Ex/c
    Bx = -Ey/c
    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Bz_A = np.zeros_like(By)
    dAydx = np.diff(np.real(Ay),axis=1)/np.diff(xv,axis=1)
    dAxdy = np.diff(np.real(Ax),axis=0)/np.diff(yv,axis=0)
    Bz_A[1:,1:] =  dAydx[1:,:] - dAxdy[:,1:]
    Bz = Bz_A + np.ones_like(Bz_A)*Bz_constant
    # B = np.stack([np.real(Bx), np.real(By), np.real(Bz)], axis=1)
    return Bx, By, Bz #.to(f"{field_units}").magnitude

def find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w):
    Ex, Ey = E_input_frame(Xv,Yv,0,take_real=False)
    Bx, By, Bz1 = E2Bv(Xv,Yv,E0i*Ex,E0i*Ey,0,c,w)
    Ex, Ey = E_input_frame(Xv,Yv,2*np.pi/4/w,take_real=False)
    Bx, By, Bz2 = E2Bv(Xv,Yv,E0i*Ex,E0i*Ey,0,c,w)
    Ex, Ey = E_input_frame(Xv,Yv,2*np.pi/2/w,take_real=False)
    Bx, By, Bz3 = E2Bv(Xv,Yv,E0i*Ex,E0i*Ey,0,c,w)
    return max([abs(np.real(Bz1)).max(), abs(np.real(Bz2)).max(), abs(np.real(Bz3)).max()]) + constant_Bz


### ------------------------------------------------------------------------------------------ ###

### Other useful functions

def light_state_contral(keyword_of_state):

    ''' Select the parameters for optical states
    options: 'lg00_l_x','lg00_l_y','lg00_c_l','lg00_c_r','lg01_l_x','lg01_l_y','lg01_c_c','lg01_c_r','lg01_c_a'
    return p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head
    '''

    p = int(keyword_of_state[2])
    l = int(keyword_of_state[3])
    if keyword_of_state[-1].lower()=='x': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [0,0,0, False,'_linear_x']
    if keyword_of_state[-1].lower()=='y': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [0,0,np.pi/2, False,'_linear_y']
    if keyword_of_state[-1].lower()=='l': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [1,0,np.pi/4, False,'_circular_l']
    if keyword_of_state[-1].lower()=='r': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [-1,0,np.pi/4, False,'_circular_r']
    output_file_head = 'LG'+str(p)+str(l)+output_file_head_suffix

## Linear polatization, Gauss:  for linear polarization, phi0_xy could be any number and s=0
    if keyword_of_state.lower()=='lg00_l_x': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,0,0,0, False,'LG00_linear_x']
    if keyword_of_state.lower()=='lg00_l_y': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,0,0,np.pi/2, False,'LG00_linear_y']
 ## Circular polatization, Gauss: for Circular polarization, phi0_xy=pi/4 and s=+-1
    if keyword_of_state.lower()=='lg00_c_l': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,1,0,np.pi/4, False,'LG00_circular_l']
    if keyword_of_state.lower()=='lg00_c_r': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,-1,0,np.pi/4, False,'LG00_circular_r']
## Linear polatization, LG01: for linear polarization, phi0_xy could be any number and s=0
    if keyword_of_state.lower()=='lg01_l_x': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,0,0,0, False,'LG01_linear_x']
    if keyword_of_state.lower()=='lg01_l_y': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,0,0,np.pi/2, False,'LG01_linear_y']
## Circular polatization, LG01 (Radial + Azimuthal): for Circular polarization, phi0_xy=pi/4 and s=+-1
    if keyword_of_state.lower()=='lg01_c_c': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,np.pi/4, False,'LG01_circular_c']
    if keyword_of_state.lower()=='lg01_c_l': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,np.pi/4, False,'LG01_circular_l']
    if keyword_of_state.lower()=='lg01_c_r': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,-1,0,np.pi/4, False,'LG01_circular_r']
## Radial polatization, LG01: for Radial polarization, s=+1, phi0_xy=0, polarization_modulation = True
    if keyword_of_state.lower()=='lg01_c_r': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,0, True,'LG01_circular_r']
## Azimuthal polatization, LG01: for Azimuthal polarization, s=+1, phi0_xy=np.pi/2, polarization_modulation = True
    if keyword_of_state.lower()=='lg01_c_a': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,np.pi/2, True,'LG01_circular_a']

    return p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head

def plot_polarization(X,Y,E_x,E_y,*,E0i:float=1.0,title:str='',figsize:(3, 3),scale:float=12,dpi:float=100):
    fig = plt.figure(figsize=figsize,constrained_layout=True,dpi=dpi)
    plt.title(title)
    plt.quiver(X,Y,E_x/E0i,E_y/E0i,scale=12, scale_units='x',width=0.1*abs(X[2]-X[1]))
    plt.xlabel('x ($\mu$m)')
    plt.ylabel('y ($\mu$m)')

def plot_EM(X,Y,E_x,E_y,B_z,*,E0i:float=1.0,title:str='',figsize:(6, 3),scale:float=12,dpi:float=100,take_Bz_range:bool=False,width_quiver:float=0.01):
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize,dpi=dpi) #constrained_layout=True,
    fig.suptitle(title)
    ax1.quiver(X,Y,E_x/E0i,E_y/E0i,scale=quiver_scale, scale_units='x',width=width_quiver*abs(X[2]-X[1]))
    ax1.set_xlabel('x ($\mu$m)')
    ax1.set_ylabel('y ($\mu$m)')
    # ax1.text(min(X)*.95, max(Y)*.85, '$|E_{0}|$: '+str(E0i), horizontalalignment='left', fontsize='large')
    ax1.set_aspect("equal")
    if take_Bz_range: Bzmax, Bzmin = [find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input), -find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input)]
    else: Bzmax, Bzmin = [B_z.max(), B_z.min()]
    contour_Bz = ax2.contourf(Xv, Yv, B_z, levels=50, linewidths=0.0, cmap="PRGn",vmin=Bzmin,vmax=Bzmax)
    cbar = plt.colorbar(contour_Bz)
    cbar.set_label('$B_{z}$ ['+field_units+']')
    ax2.set_xlabel('x ($\mu$m)')
    ax2.set_ylabel('y ($\mu$m)')
    # ax2.text(min(X)*.95, max(Y)*.85, '$|B_{z,0}|$: '+str(E0i), horizontalalignment='left', fontsize='large')
    ax2.set_aspect("equal")

def v_grid_generation(p1,p2,p3,p4,quiver_mesh_n): # (-width/2,width/2,-height/2,height/2,quiver_mesh_n)
    X = np.linspace(p1,p2,quiver_mesh_n)
    Y = np.linspace(p3,p4,quiver_mesh_n)
    Xv, Yv = np.meshgrid(X, Y)
    Zv = np.zeros_like(Xv)
    return X, Y, Xv, Yv, Zv

### Unit transfer and check

from datetime import datetime
import pytz

def Unit_check_save(E0i,w0,w,light_source_state,length_units,E_field_units,angular_freq_units,subtitle,solve_time,screenSet,folder_name,Bz_max):

    ## Unit transfer
    w0 = (w0 * ureg(length_units)).to(length_units).magnitude   # Beam waist (suppose w0_x =w0_y)
    tau = tau_0.to(time_units).magnitude   # Unit time
    c = (cons.speed_of_light * ureg('m/s').to(length_units+'/'+time_units) * tau).magnitude   # speed of light (3e8 * tau  m/s)
    p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = light_state_contral(light_source_state)
    B0 = (1/c) * ureg(field_units)
    A0 = (1/w) * ureg(f"{field_units} * {length_units}")
    E0 = B0 * speed_of_light

    ## Save to data
    file_name = folder_name+'/'+subtitle+output_file_head+"_rec.txt"
    f = open(file_name, "w")
    f.write("File name "+file_name+"\n")
    f.write("Time now (at Stockholm):"+str(datetime.now(pytz.timezone('Europe/Stockholm')))+"\n")
    f.write(":: Parameter record ::\n")
    f.write("[1] Length scale of sample\n")
    f.write("Coherent length (xi): "+str(xi_coherent)+"\n")
    f.write("London penetration depth (london_lambda): "+str(lambdaL)+"\n")
    f.write("Thickness (thickness): "+str(d_thickness)+"\n")
    f.write("Screen length (lambdaL**2/thickness): "+str(screen_length)+"\n")
    f.write("Ratio of length kapa (lambdaL/xi): "+str(lambdaL/xi_coherent)+"\n")
    f.write("[2] Condictivity and  of sample\n")
    f.write("Resistivity (resistivity): "+str(resistivity)+"\n")
    f.write("Condictivity (1/resistivity): "+str(condictivity)+"\n")
    f.write("[3] Time scale of sample\n")
    f.write("Characteristic timescale (tau_0): "+str(tau_0.to(time_units))+"\n") # characteristic timescale for this TDGL model
    f.write("Characteristic rate (1/tau_0): "+str((1/tau_0).to('THz'))+"\n")
    f.write("Speed of light (unit of tau_0): "+str(revised_speed_of_light)+"\n")
    f.write("c input into A_LG (c): "+str(c)+"\n")
    f.write("tau input into A_LG (tau_0.to(s)): "+str(tau)+"\n")
    f.write("k calculated inside A_LG (w/c): "+str(w/c)+"\n")
    f.write("[4] Gap of sample\n")
    f.write("Given inelastic coupling rate (rate_eph): "+str(E_eph)+"\n")
    f.write("Given SC gap energy (gap_0): "+str(E_gap_0)+"\n")
    f.write("Frequency of SC gap (gap_0*0.242): "+str(F_gap_0)+"\n")
    f.write("Strength of inelastic scattering (gamma=2/rate_eph*gap_0): "+str(gamma)+"\n")
    f.write("[5] Parameters of light source\n")
    f.write("Beam size (2w0): "+str(2*w0 * ureg(length_units))+"\n")
    wavelength_of_light = (cons.speed_of_light * ureg('m/s') / ((w/2/np.pi/tau_0).to('THz'))).to(length_units)
    f.write("Wavelength: "+str(wavelength_of_light)+"\n")
    f.write("Beam size / wavelength: "+str((2*w0 * ureg(length_units)) / wavelength_of_light)+"\n")
    if (2*w0 * ureg(length_units) / wavelength_of_light).magnitude<1: print('[Warning] !!! ---Beam size is smaller than wavelength.--- !!!')
    if time_evolute: f.write("Angular frequency of light (w, unit of tau): "+str(w)+"\n")
    if time_evolute: f.write("Angular frequency of light (w, real value): "+str((w/tau_0).to(angular_freq_units))+"\n")
    if time_evolute: f.write("Frequency of light (w/2pi, unit of tau): "+str(w/2/np.pi)+"\n")
    if time_evolute: f.write("Frequency of light (w/2pi, real value): "+str((w/2/np.pi/tau_0).to(angular_freq_units))+"\n")
    if time_evolute!=True: f.write("Time evolution setting is False (no frequency is used).")
    f.write("EM field switch-on at (unit of tau): "+str(t_on)+"\n")
    f.write("EM field switch-off at (unit of tau): "+str(t_off)+"\n")
    f.write("|E0| of light (case of E0=1): "+str(E0.to(E_field_units))+"\n")
    f.write("In-plane |B0| of light (|E0|/c): "+str(B0)+"\n")
    f.write("In-plane |A0| of light (|E0|/w): "+str(A0)+"\n")
    f.write("Check ratio of 2pi|A0|/|B0|: "+str(2*np.pi*A0/B0)+"\n")
    f.write("|Bz| of light: "+str(Bz_max * ureg(field_units))+"\n")
    f.write("Range of input |E0| (E0i): "+str(E0i)+"\n")
    f.write("Degree of LG mode (p): "+str(p)+"\n")
    f.write("Order of LG mode (l): "+str(l)+"\n")
    f.write("Spin number (s): "+str(s)+"\n")
    f.write("Initial phase of time (phi0_t): "+str(phi0_t)+"\n")
    f.write("Initial azimuthal angle (phi0_xy): "+str(phi0_xy)+"\n")
    f.write("Polarization modulation (T/F): "+str(polarization_modulation)+"\n")
    f.write("output_file_head (string): "+output_file_head+"\n")
    f.write("[6] Critical E and B of SC\n")
    f.write("Quantum magnetic flux (Phi0 = h/2e): "+str(cons.h/2/cons.e * ureg('J/A').to('W/A*s'))+"\n")
    f.write("Hc1 of SC (Phi0/4pi/lambda^2*ln[lambda/xi]): "+str(Hc1)+"\n") # [ref] Gennes.P.D., pp.66, Eq (3-56)
    f.write("Hc2 of SC (Phi0/2pi xi^2): "+str(Hc2)+"\n")
    f.write("Hc of SC: "+str(Hc)+"\n")
    f.write("Bc1 of SC (mu0Hc1): "+str((mu_0*Hc1).to('T'))+"\n") # lower critical field
    f.write("Bc2 of SC (mu0Hc2): "+str((mu_0*Hc2).to('T'))+"\n") # upper critical field
    f.write("Bc of SC: "+str(Bc.to('T'))+"\n")
    f.write("Bc*2pi*w0^2/Phi0: "+str(mu_0*Hc*2*np.pi*(w0*ureg(length_units))**2/Phi0)+"\n")
    f.write("Bc2*2pi*w0^2/Phi0: "+str(mu_0*Hc2*2*np.pi*(w0*ureg(length_units))**2/Phi0)+"\n")
    f.write("Critical vector potential A0 (xi*Bc2): "+str(xi_coherent*Bc2)+"\n")
    f.write("Unit current density (J0 = 4*xi*Bc2/mu_0/lambdaL**2): "+str(4*xi_coherent*Bc2/mu_0/lambdaL**2)+"\n")
    f.write("|B0|/Bc: "+str(B0/((mu_0*Hc).to(field_units)))+"\n") # upper critical field
    f.write("|Bz|/Bc: "+str(Bz_max*ureg(field_units)/((mu_0*Hc).to(field_units)))+"\n") # upper critical field
    f.write("Fermi velocity: "+str(vF.to('m/s'))+"\n")
    f.write("Fermi velocity (unit of c): "+str(vF.to('m/s')/(speed_of_light))+"\n")
    f.write("Condensation energy (Bc**2/2/mu0): "+str(Econd.to('eV/'+length_units+'**3'))+"\n")
    f.write("[7] Others\n")
    f.write("Applied constant Bz: "+str(constant_Bz * ureg(field_units))+"\n")
    f.write("Solve time (unit of tau_0): "+str(solve_time)+"\n")
    f.write("Screen Set (T/F): "+str(screenSet)+"\n")
    f.close()

    ## Print and check
    f = open(file_name, "r")
    print(f.read())
    print('... Save to file: '+file_name)
    f.close()

    return tau, c


""" Example of EMwave_G_cir:
applied_vector_potential = EMwave_G_cir(w=1e8, E0=1, phi0=0)
"""

""" Example of A_LG:
E0i = 10
w_input = 2*np.pi
w0 = 0.1
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,0,0,0,0, False]       ## Linear polatization, Gauss:  for linear polarization, phi0_xy could be any number and s=0
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,0,1,0,np.pi/4, False] ## Circular polatization, Gauss: for Circular polarization, phi0_xy=pi/4 and s=+-1
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,0,0,0, False]       ## Linear polatization, LG01: for linear polarization, phi0_xy could be any number and s=0
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,1,0,np.pi/4, False] ## Circular polatization, LG01 (Radial + Azimuthal): for Circular polarization, phi0_xy=pi/4 and s=+-1
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,1,0,0, True]        ## Radial polatization, LG01: for Radial polarization, s=+1, phi0_xy=0, polarization_modulation = True
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,1,0,np.pi/2, True]  ## Azimuthal platization, LG01: for Azimuthal polarization, s=+1, phi0_xy=np.pi/2, polarization_modulation = True
applied_vector_potential = A_LG(w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
"""

""" Example of A_LG_step:
E0i = 10
w_input = 2*np.pi
w0 = 0.1
Bz = 1
t_on, t_off = [0.0, 2.0]
applied_vector_potential = A_LG(w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             t_on=t_on, t_off=t_off, Bz=Bz, time_evolute=True,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, field_units=field_units,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
"""

""" Example of A2B(x, y, z, A)

applied_vector_potential_t = A_LG_t(x=x, y=y, z=z, t=t, w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             t_on=t_on, t_off=t_off, Bz=Bz, time_evolute=True,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, field_units=field_units,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
B = A2B(x, y, z, applied_vector_potential_t)
# Bx = B.x
# By = B.y
# Bz = B.z

E_LG_beam_t = E_LG_t(x=xv, y=yv, z=zv, t=t, w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             t_on=t_on, t_off=t_off, Bz=Bz_constant, time_evolute=True,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, field_units=field_units,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
applied_magnetic_field_t = E2Bv(xv,yv,E,Bz_constant,c,w)
# Bx = applied_magnetic_field_t[:,0]
# By = applied_magnetic_field_t[:,1]
# Bz = applied_magnetic_field_t[:,2]
"""

""" Test of avalability of function: (for the error of saving data)
# pickle.dumps(applied_vector_potential)
# np.dtype(applied_vector_potential)
# print(applied_vector_potential.dtype)
import pickle
import cloudpickle

applied_vector_potential2 = A_LG(w=1, w0=2, E0=3, phi0_t=4, phi0_xy=5, p=1, l=2, s=3, tau=1)

# np.void(cloudpickle.dumps(applied_vector_potential2))
applied_vector_potential2 = A_LG(w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
# pickle.dumps(applied_vector_potential2)
cloudpickle.dumps(applied_vector_potential2)
"""

""" Select the parameters for optical states via "light_state_contral(keyword_of_state)":
options: 'lg00_l_x','lg00_l_y','lg00_c_l','lg00_c_r','lg01_l_x','lg01_l_y','lg01_c_c','lg01_c_r','lg01_c_a'
return p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head
"""

"""Example of Unit_check_save:
Unit_check_save(E0i,w0,w,light_source_type,length_units,E_field_units,angular_freq_units,subtitle)
"""

""" Example of MAKE_ANIMATIONS:
if MAKE_ANIMATIONS:
    test_video = make_video_from_solution(
        test_solution,
        quantities=["order_parameter", "phase", "scalar_potential","vorticity"],
        figsize=(22, 4),
    )
    display(test_video)
"""

# pip install cupy-cuda11x
# pip install cupy-cuda12x

""" Done."""

"""## Main scipts
The calculation of spatially- and temporally-resolved Generalized time-dependent GinzburgLandau (gTDGL) simulation. Deteails please refer Logan's paper [DOI: 10.1016/j.cpc.2023.108799].

### Part 1: Defining the device
Input the parameters for defining the SC thin film and constructing mesh for SC film.
<!-- Here we define a film with effective magnetic screening length $\Lambda=\lambda^2/d=(2\,\mu\mathrm{m})^2 / (0.05\,\mu\mathrm{m})=80\,\mu\mathrm{m}$, which is much larger than the dimensions of the sample. We therefore expect screening to be not important for this model. -->
"""

### Unit setting

import scipy.constants as cons
from pint import UnitRegistry
ureg = UnitRegistry()

length_units = "um" # SI: m
time_units = 'ps' # SI: s
current_units = "mA" # SI: A
mass_units = 'kg' # SI: kg
angular_freq_units = 'THz' # SI: 1/s # for demonstration
field_units = "mT" # SI: kg/s^2/A
E_field_units = "kvolt/meter" # newton per coulomb (N/C), or volt per meter (V/m), SI: kg*m^2/s^3/A


### SC properties

xi = 100/1000 # Coherent length
london_lambda = 100/1000 # London penetration depth

rate_eph = 4 # [meV], 40 meV calculated from tau_eph = 100fs for YBCO, https://journals.aps.org/prb/abstract/10.1103/PhysRevB.59.1497
gap_0 = 20 # [meV], 20 meV https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.65.801, https://arxiv.org/pdf/cond-mat/9910367.pdf
# gap ~ 1/0.57*Tc https://people.phys.ethz.ch/~ivanov/cmt/1314/ssth-lectureBC.pdf
# For the case of Niobium gap_0=2.3meV & rate_eph=11, gamma is ~0.4 => no vortex
# gamma = 2/rate_eph*gap_0
gamma = 10
u = 5.79

temperature = 0.5 # Unit of Tc
disorder_epsilon = 1/temperature-1

# Size of sample
height = 4
width = 6
thickness = 2/1000

# Conductivity of sample
resistivity = 150e-6 * ureg('ohm * cm')
condictivity = (1/resistivity).to('1 / ohm / '+length_units)

from tdgl.geometry import box
source = (
    tdgl.Polygon("source", points=box(1.1 * width, height / 100))
    .translate(dy=height / 2)
)
drain = source.scale(yfact=-1).set_name("drain")
#  Voltage measurement points
probe_points = [(2.8, 0.5), ( -2.8, 0.5)]


layer = tdgl.Layer(coherence_length=xi, london_lambda=london_lambda, thickness=thickness, gamma=gamma, u=u, conductivity=condictivity.magnitude)
film = tdgl.Polygon("film", points=tdgl.geometry.box(width, height, points=301))
device = tdgl.Device(
    "bar",
    layer=layer,
    film=film,
    terminals=[source, drain],
    length_units=length_units,
    probe_points=probe_points,
)

#  device.make_mesh(max_edge_length=xi / mesh_size, smooth=100)
#  fig, ax = device.plot(mesh=True, legend=False)
#  device.mesh_stats()

#  fluxoid_curves = [
#      box(2, center=(-2.5, 0)),
#      box(2, center=(2.5, 0)),
#  ]

"""### Check Unit
This scipts is based on unitless gTDGL funtion. So this cell is for cheking unit based on the parameters.

"""

# PrintSet = True
PrintSet = False

## SC parameters
length_units = str(length_units)

if PrintSet: print('Length scale of sample')
mu_0 = cons.mu_0 * ureg('newton/A**2')
xi_coherent = xi * ureg(length_units)
if PrintSet: print('- Coherent length: {!s}'.format(xi_coherent))
lambdaL = london_lambda * ureg(length_units)
if PrintSet: print('- London penetration depth: {!s}'.format(lambdaL))
d_thickness = thickness * ureg(length_units)
lambdaL_eff = lambdaL**2/d_thickness
if PrintSet: print('- Effective London penetration depth (l^2/d): {!s}'.format(lambdaL_eff))
if PrintSet: print('- Thickness: {!s}'.format(d_thickness))
L_height = height * ureg(length_units)
L_width = width * ureg(length_units)
if PrintSet: print('- Height: {!s}'.format(L_height))
if PrintSet: print('- Width: {!s}'.format(L_width))
screen_length = lambdaL**2/d_thickness
if PrintSet: print('- Screen length: {!s}'.format(screen_length))

if PrintSet: print('Condictivitye of sample')
resistivity = 150e-6 * ureg('ohm * cm')
condictivity = 1/resistivity
if PrintSet: print('- Given resistivity: {!s}'.format(resistivity))
if PrintSet: print('- Given condictivity: {!s}'.format(condictivity))

if PrintSet: print('Gap of sample')
E_eph = rate_eph * ureg('meV')
E_gap_0 = gap_0 * ureg('meV')
F_gap_0 = gap_0*0.242 * ureg('THz')
if PrintSet: print('- Given inelastic coupling rate: {!s}'.format(E_eph))
if PrintSet: print('- Given SC gap energy: {!s}'.format(E_gap_0))
if PrintSet: print('- Given SC gap energy: {!s}'.format(F_gap_0))
if PrintSet: print('- Strength of inelastic scattering: {!s}'.format(gamma))


## Unit of Time

if PrintSet: print('Time scale of sample')
# tau_0 = 2 * ureg('s')# mu_0 * condictivity * lambdaL**2
tau_0 = mu_0 * condictivity * lambdaL**2
tau_0 = tau_0.to('s')
if PrintSet: print('- SC dissipation time (tau_0): {!s}'.format(tau_0.to(time_units)))
speed_of_light = cons.speed_of_light * ureg('m/s')
revised_speed_of_light = (speed_of_light*tau_0.to(time_units).magnitude)
if PrintSet: print('- Speed of light (unit of tau_0):  {!s}'.format(revised_speed_of_light.to('um/ps')))


## Angular frequency of 1 THz ( =2f)

if PrintSet: print('Given frequency of light')
w_Freq = (1/tau_0)
f_input = 1 * w_Freq
w_input = 2*np.pi * f_input
if PrintSet: print('- SC dissipation rate: {!s}'.format(w_Freq.to(angular_freq_units)))
if PrintSet: print('- Expected frequency of light: {!s}'.format(f_input.to(angular_freq_units)))
if PrintSet: print('- Expected angular frequency of light: {!s}'.format(w_input.to(angular_freq_units)))
w0 = ((speed_of_light/(f_input.to(angular_freq_units))).to('um'))
if PrintSet: print('- Wavelength estimation for w0: '+str(w0))
if PrintSet: print('- Useful ratio estimation w0/xi: '+str(w0/xi_coherent))
if PrintSet: print('- Useful ratio estimation xi/tau_GL: '+str(xi_coherent.to('um')/tau_0.to('ps')))
if PrintSet: print('- Useful ratio estimation w0/tau_LG: '+str(w0.to('um')/tau_0.to('ps')))


## Electrical field and Magnetic field Phi_0

if PrintSet: print('E and B of light')
c_rev = revised_speed_of_light.to(length_units+'/'+time_units).magnitude
B0_check = (1/(c_rev)) * ureg(field_units)#*tau_0.to(time_units).magnitude
A0_check = (1/2/np.pi) * ureg(f"{field_units} * {length_units}") # Suppose w_input = 2*pi
B0 = B0_check
E0 = B0 * speed_of_light
if PrintSet: print('- |E0| of light: {!s}'.format(E0.to(E_field_units)))
if PrintSet: print('- |B0| of light: {!s}'.format(B0.to(field_units)))
if PrintSet: print('- |B0| of inside the function: {!s}'.format(B0_check.to(field_units)))
if PrintSet: print('- |A0| of inside the function: {!s}'.format(A0_check.to(field_units+'*'+length_units)))
if PrintSet: print('- 2pi|A0|/|B0|=Wavelength defined inside the function: {!s}'.format((A0_check*2*np.pi/B0_check).to(length_units)))
    # superconducting flux quantum: Phi0 = h/2e
    # upper critical field: Bc2 = 0Hc2 = Phi0/2^2
if PrintSet: print('Critical E and B of SC')
Phi0 = cons.h/2/cons.e * ureg('J/A')
Hc1 = Phi0/4/np.pi/mu_0/lambdaL**2*np.log(lambdaL/xi_coherent) # [ref] Gennes.P.D., pp.66, Eq (3-56), but no mu_0
Hc2 = Phi0/2/np.pi/mu_0/xi_coherent**2 # [ref] Logan
Hc  = Hc1/(np.pi/np.sqrt(24)*xi_coherent/lambdaL*np.log(lambdaL/xi_coherent)) # [ref] Gennes.P.D., pp.66, Eq (3-56), but no mu_0
Bc1 = mu_0*Hc1
Bc2 = mu_0*Hc2
Bc  = mu_0*Hc
A0_critical = xi_coherent*Bc2
# Econd = (1/2)VN(0)2
# Econd = # [ref] Gennes.P.D., pp.66, Eq (3-41)
# Econd = Hc1**2/8/np.pi # [ref] Gennes.P.D., pp.66, Eq (3-1) # Gauss unit
Econd = Bc**2/2/mu_0
hbar = cons.hbar * ureg('J*s')
vF = np.pi*xi_coherent*E_gap_0/hbar # [ref] Gennes.P.D., pp.66, Eq (3-40)
if PrintSet: print('- Phi0: {!s}'.format(Phi0))
if PrintSet: print('- Hc1 of SC: {!s}'.format(Hc1))
if PrintSet: print('- Hc2 of SC: {!s}'.format(Hc2))
if PrintSet: print('- Bc1 of SC: {!s}'.format(Bc1.to('T')))
if PrintSet: print('- Bc2 of SC: {!s}'.format(Bc2.to('T')))
if PrintSet: print('- Critical vector potential A0: {!s}'.format(A0_critical.to('T*um')))
J0 = 4*xi_coherent*Bc2/mu_0/lambdaL**2
if PrintSet: print('- Unit current density: {!s}'.format(J0.to('A/um^2')))
if PrintSet: print('- Condensation energy (Bc**2/2/mu0): {!s}'.format(Econd.to('eV/'+length_units+'**3')))

""" Done!"""

"""### Setting of Laguerre-Gaussian Beam
Inputing the parameters for Laguerre-Gaussian Beam. <br>
!!! Impotent !!! this cell will clean up the files in filefolder @folder_name.
"""

### Make filefolder for saving ###

Parameter_set = {}

w0 = 0.75
quiver_scale = 4
xc_Gauss = 0
yc_Gauss = 0
gamma = 10
light_source_type = 'lg00_c_l'


### Parameter setting ###

w_input = np.copy(w_input_set)
case_name = 'I_'+str(int(current_amp*1000))+'_E_'+str(int(E0i*1000))
Parameter_set[case_name] = {'E0i':E0i,'light_source_type':light_source_type,'current_amp':current_amp}
screenSet = False
constant_Bz = 0

quiver_mesh_n = 20
# quiver_scale = 5
width_quiver = 0.1
dpi = 100
SC_solution_all = {}

""" Done ! """

"""================================================================================="""
"""### Part 2: Make filefolder for saving ###
====================================================================================
"""

newpath = r'/gpfs/sharedfs1/alb16177/vap24003/OutputData/20250810_Confine_CP_SI/'+case_name+'/'

if not os.path.exists(newpath): os.makedirs(newpath)
folder_name = newpath

ReadCurrent, E0set, solve_time, file_name = current_amp, E0i, 500, 'LG00_circular_l_time500_SC_solution'+case_name+'.h5'
folder_name, folder_name_fig = np.copy(newpath), np.copy(newpath)
datafolder =  r'/gpfs/sharedfs1/alb16177/vap24003/OutputData/20250421_Confine_CP_all/'+case_name+'/'

subtitle = '20250614_Ek_I_'+str(int(ReadCurrent*1000))+'_E_'+str(int(E0set*1000))

### Parameter setting ###

light_source_type = 'lg00_c_l'
# current_amp = ReadCurrent # current_units
# E0i = E0set
Parameter_set[case_name] = {'E0i':E0i,'light_source_type':light_source_type}
E0i_set = [E0i]

quiver_mesh_n = 50
quiver_scale = 2
width_quiver = 0.02
dpi = 100
E0i = E0i_set[0]

## Select the parameters for the states of light sourceu
## options: 'lg00_l_x','lg00_l_y','lg00_c_l','lg00_c_r','lg01_l_x','lg01_l_y','lg01_c_c','lg01_c_r','lg01_c_a'
p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = light_state_contral(light_source_type)

constant_Bz = 0
t_on, t_off, time_evolute = [0.0, solve_time, True]

### Save and print

def E_input_frame(Xv,Yv,ti,*,take_real: bool=True):
    Zv = np.zeros_like(Xv)
    Ex, Ey, Ez =  (E_LG_t(Xv, Yv, Zv, t=ti, w=w_input, w0=w0, E0=E0i, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                             t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,))
    if take_real: return np.real(Ex)/E0i, np.real(Ey)/E0i
    else:         return Ex/E0i, Ey/E0i

# delete_files_in_directory(folder_name)
fig_title0 = folder_name+'/'+subtitle+output_file_head
X, Y, Xv, Yv, Zv = v_grid_generation(-width/2,width/2,-height/2,height/2,quiver_mesh_n)
Bz_max = find_max_Bz(Xv,Yv,1,0,revised_speed_of_light.to('um/ps').magnitude,w_input)
tau, c = Unit_check_save(E0i_set,w0,w_input,light_source_type,length_units,E_field_units,angular_freq_units,subtitle,solve_time,screenSet,folder_name,Bz_max)

quiver_test = True
if quiver_test:
        title_set = 'quiver test'
        E_x, E_y, E_z = (E_LG_t(Xv, Yv, Zv, t=0, w=w_input, w0=w0, E0=E0i_set[0], xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
                                 phi0_t=0*np.pi/2, phi0_xy=phi0_xy, p=p, l=l, s=s,
                                 t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute,
                                 tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                                 angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,))
        B_x, B_y, B_z = E2Bv(Xv,Yv,E_x,E_y,constant_Bz,c,w_input)
        plot_EM(X,Y,np.real(E_x),np.real(E_y),np.real(B_z),E0i=E0i_set[0],title=title_set,figsize=(9,3),scale=quiver_scale,dpi=dpi,width_quiver=width_quiver)

""" Done ! """

"""================================================================================="""
"""### Part 3: Load vortex anaysis functions ###
====================================================================================
"""

from tdgl.solution.data import TDGLData, get_edge_quantity_data, load_state_data
from tdgl.finite_volume.operators import build_gradient

def get_vorticity(
    h5file: h5py.File,
    mesh,
    quantity: Quantity,
    frame: int,
):
    """Get data to plot.

    Args:
        h5file: The data file.
        mesh: The mesh used in the simulation.
        quantity: The quantity to return.
        frame: The current frame.

    Returns:
        A tuple of the values for the color plot, the directions for the
        quiver plot and the limits for the color plot.
    """
    tdgl_data = TDGLData.from_hdf5(h5file, frame)
    psi = tdgl_data.psi
    mu = tdgl_data.mu
    epsilon = tdgl_data.epsilon
    a_applied = tdgl_data.applied_vector_potential
    a_induced = tdgl_data.induced_vector_potential
    supercurrent = tdgl_data.supercurrent
    normal_current = tdgl_data.normal_current
    nsites = len(mesh.sites)

    if True:
        j_sc_site = mesh.get_quantity_on_site(supercurrent)
        j_nm_site = mesh.get_quantity_on_site(normal_current)
        j_site = j_sc_site + j_nm_site
        gradient = build_gradient(mesh)
        normalized_directions = mesh.edge_mesh.normalized_directions
        grad_jx = gradient @ j_site[:, 0]
        grad_jy = gradient @ j_site[:, 1]
        djy_dx = grad_jy * normalized_directions[:, 0]
        djx_dy = grad_jx * normalized_directions[:, 1]
        vorticity_on_edges = djy_dx - djx_dy
        vorticity = mesh.get_quantity_on_site(vorticity_on_edges, vector=False)
        vmax = max(np.abs(np.max(vorticity)), np.abs(np.min(vorticity)))
    return vorticity#, np.zeros((nsites, 2)), [-vmax, vmax]

# from tdgl.finite_volume import mesh
from tdgl.finite_volume.mesh import Mesh
from tdgl.finite_volume.edge_mesh import EdgeMesh

def from_hdf5(h5group: h5py.Group) -> "Mesh":
        """Load a mesh from an HDF5 file.

        Args:
            h5group: The HDF5 group to load the mesh from.

        Returns:
            The loaded mesh.
        """
        if not ("sites" in h5group and "elements" in h5group):
            raise IOError("Could not load mesh due to missing data.")

        if Mesh.is_restorable(h5group):
            polygons_flat = np.array(h5group["voronoi_polygons_flat"])
            voronoi_indices = np.array(h5group["voronoi_split_indices"])
            voronoi_polygons = np.split(polygons_flat, voronoi_indices)
            return Mesh(
                sites=np.array(h5group["sites"]),
                elements=np.array(h5group["elements"], dtype=np.int64),
                boundary_indices=np.array(h5group["boundary_indices"], dtype=np.int64),
                areas=np.array(h5group["areas"]),
                dual_sites=np.array(h5group["dual_sites"]),
                voronoi_polygons=voronoi_polygons,
                edge_mesh=EdgeMesh.from_hdf5(h5group["edge_mesh"]),
            )
        # Recreate mesh from triangulation data if not all data is available
        return Mesh.from_triangulation(
            sites=np.array(h5group["sites"]).squeeze(),
            elements=np.array(h5group["elements"]),
        )

def find_index(POS,val):
    min_rec = np.zeros(len(val))
    for i in range(len(val)):
        min_rec[i] = np.sum(abs(val[i,:]-POS)**2)
    return np.argmin(min_rec)
    

print('Load function for J and vorticity')

def get_J(
    h5file: h5py.File,
    mesh,
    quantity: Quantity,
    frame: int,
):
    """Get data to plot.

    Args:
        h5file: The data file.
        mesh: The mesh used in the simulation.
        quantity: The quantity to return.
        frame: The current frame.

    Returns:
        A tuple of the values for the color plot, the directions for the
        quiver plot and the limits for the color plot.
    """
    tdgl_data = TDGLData.from_hdf5(h5file, frame)
    psi = tdgl_data.psi
    mu = tdgl_data.mu
    epsilon = tdgl_data.epsilon
    a_applied = tdgl_data.applied_vector_potential
    a_induced = tdgl_data.induced_vector_potential
    supercurrent = tdgl_data.supercurrent
    normal_current = tdgl_data.normal_current
    nsites = len(mesh.sites)
    j_sc_site = mesh.get_quantity_on_site(supercurrent)
    j_nm_site = mesh.get_quantity_on_site(normal_current)

    if quantity=='n': j_site = j_nm_site
    elif quantity=='s': j_site = j_sc_site
    else: j_site = j_sc_site + j_nm_site
    J = np.sqrt(j_site[:, 0]**2 + j_site[:, 1]**2)

    return J #, np.zeros((nsites, 2)), [-vmax, vmax]

def get_Jv(
    h5file: h5py.File,
    mesh,
    quantity: Quantity,
    frame: int,
):
    """Get data to plot.

    Args:
        h5file: The data file.
        mesh: The mesh used in the simulation.
        quantity: The quantity to return.
        frame: The current frame.

    Returns:
        A tuple of the values for the color plot, the directions for the
        quiver plot and the limits for the color plot.
    """
    tdgl_data = TDGLData.from_hdf5(h5file, frame)
    psi = tdgl_data.psi
    mu = tdgl_data.mu
    epsilon = tdgl_data.epsilon
    a_applied = tdgl_data.applied_vector_potential
    a_induced = tdgl_data.induced_vector_potential
    supercurrent = tdgl_data.supercurrent
    normal_current = tdgl_data.normal_current
    nsites = len(mesh.sites)
    j_sc_site = mesh.get_quantity_on_site(supercurrent)
    j_nm_site = mesh.get_quantity_on_site(normal_current)

    if quantity=='n': j_site = j_nm_site
    elif quantity=='s': j_site = j_sc_site
    else: j_site = j_sc_site + j_nm_site
    Jx = j_site[:, 0]
    Jy = j_site[:, 1]

    return Jx, Jy #, np.zeros((nsites, 2)), [-vmax, vmax]

def get_J_all(
    h5file: h5py.File,
    mesh,
    quantity: Quantity,
    frame: int,
):
    """Get data to plot.

    Args:
        h5file: The data file.
        mesh: The mesh used in the simulation.
        quantity: The quantity to return.
        frame: The current frame.

    Returns:
        A tuple of the values for the color plot, the directions for the
        quiver plot and the limits for the color plot.
    """
    tdgl_data = TDGLData.from_hdf5(h5file, frame)
    psi = tdgl_data.psi
    rho = abs(psi)**2
    mu = tdgl_data.mu
    epsilon = tdgl_data.epsilon
    a_applied = tdgl_data.applied_vector_potential
    a_induced = tdgl_data.induced_vector_potential
    supercurrent = tdgl_data.supercurrent # Unit: K0 (current/length)
    normal_current = tdgl_data.normal_current # Unit: K0 (current/length)
    nsites = len(mesh.sites)

    if True:
        j_sc_site = mesh.get_quantity_on_site(supercurrent)
        j_nm_site = mesh.get_quantity_on_site(normal_current)
        gradient = build_gradient(mesh)
        normalized_directions = mesh.edge_mesh.normalized_directions

        j_site = np.copy(j_sc_site)
        grad_jx = gradient @ j_site[:, 0]
        grad_jy = gradient @ j_site[:, 1]
        djy_dx = grad_jy * normalized_directions[:, 0]
        djx_dy = grad_jx * normalized_directions[:, 1]
        vorticity_on_edges = djy_dx - djx_dy
        vorticity_sc = mesh.get_quantity_on_site(vorticity_on_edges, vector=False)
        # vmax = max(np.abs(np.max(vorticity)), np.abs(np.min(vorticity)))
        J_sc = np.sqrt(j_site[:, 0]**2 + j_site[:, 1]**2)
        J_sc_vec = j_site
        vorticity_sc[np.isnan(vorticity_sc)] = 0
        vorticity_sc[np.isinf(vorticity_sc)] = 0

        j_site = np.copy(j_nm_site)
        grad_jx = gradient @ j_site[:, 0]
        grad_jy = gradient @ j_site[:, 1]
        djy_dx = grad_jy * normalized_directions[:, 0]
        djx_dy = grad_jx * normalized_directions[:, 1]
        vorticity_on_edges = djy_dx - djx_dy
        vorticity_nm = mesh.get_quantity_on_site(vorticity_on_edges, vector=False)
        # vmax = max(np.abs(np.max(vorticity)), np.abs(np.min(vorticity)))
        J_nm = np.sqrt(j_site[:, 0]**2 + j_site[:, 1]**2)
        J_nm_vec = j_site

        j_site = np.copy(j_sc_site)
        grad_jx = gradient @ (j_site[:, 0]/rho)
        grad_jy = gradient @ (j_site[:, 1]/rho)
        djy_dx = grad_jy * normalized_directions[:, 0]
        djx_dy = grad_jx * normalized_directions[:, 1]
        vorticity_on_edges = djy_dx - djx_dy
        vorticity_scv = mesh.get_quantity_on_site(vorticity_on_edges, vector=False)
        vorticity_scv[np.isnan(vorticity_sc)] = 0
        vorticity_scv[np.isinf(vorticity_sc)] = 0

    return J_sc, J_nm, vorticity_sc, vorticity_nm, mu, J_sc_vec, J_nm_vec, vorticity_scv

''' loading get_J, get_J_all, Done. '''


print('Function for tracking vortex and F_M')

class J2v:
    def __init__(self,J_vec,rho):
        v = np.zeros_like(J_vec)
        v[:,0] = J_vec[:,0]/rho
        v[:,1] = J_vec[:,1]/rho
        v[np.isnan(v)] = 0
        v[np.isinf(v)] = 0
        self.v = v
        self.mag = np.sqrt(v[:,0]**2+v[:,1]**2)
        self.x = v[:,0]
        self.y = v[:,1]

def circulation(mesh,vor,pos,vor_range): # Stokes' theorem
    distance = np.sqrt((mesh.x-pos[0])**2+(mesh.y-pos[1])**2)
    S_integral = np.zeros_like(mesh.x)
    S_integral[np.where(distance<=vor_range)] = 1.0
    return sum(S_integral*vor*mesh.areas)

def Vtrack(rec,mesh,Vor,mask,n_ti,t_set,*,vor_range:float=2.0,):
    X, Y = mesh.x, mesh.y
    if n_ti==0:
        iniArr = np.zeros([len(t_set), 2], dtype=float)
        rec['V']  = {'pos':np.copy(iniArr),'vL':np.copy(iniArr),'K':np.zeros_like(t_set, dtype=float)}
        rec['aV'] = {'pos':np.copy(iniArr),'vL':np.copy(iniArr),'K':np.zeros_like(t_set, dtype=float)}
    pos1 = np.copy(np.argmax(Vor*mask))
    pos2 = np.copy(np.argmin(Vor*mask))
    rec['V']['pos'][n_ti,:]  = np.copy(X[pos1]), np.copy(Y[pos1])
    rec['aV']['pos'][n_ti,:] = np.copy(X[pos2]), np.copy(Y[pos2])
    # Circulation of vortex and antivortex. vor_range = 2*xi
    rec['V']['K'][n_ti]  = circulation(mesh,Vor,rec['V']['pos'][n_ti,:],vor_range)
    rec['aV']['K'][n_ti] = circulation(mesh,Vor,rec['aV']['pos'][n_ti,:],vor_range)
    # Velocity of vortex and antivortex.
    if n_ti>0:
        rec['V']['vL'][n_ti,:]  = np.copy((rec['V']['pos'][n_ti,:]-rec['V']['pos'][n_ti-1,:])/(t_set[n_ti]-t_set[n_ti-1]))
        rec['aV']['vL'][n_ti,:] = np.copy((rec['aV']['pos'][n_ti,:]-rec['aV']['pos'][n_ti-1,:])/(t_set[n_ti]-t_set[n_ti-1]))
    return rec


''' Done. '''

"""================================================================================="""
"""### Part 4: Load .h5 file ###
====================================================================================
"""

import h5py
import glob
import os

light_source_type = 'lg00_c_l'
# width, height = width, height
# w_input = w_input
# solve_time = solve_time

case_name = 'I_'+str(int(current_amp*1000))+'_E_'+str(int(E0i*1000))
ReadCurrent, E0set, solve_time, file_name = np.copy(current_amp), np.copy(E0i), 500, '/'+case_name+'/LG00_circular_l_time500_SC_solution'+case_name+'.h5'
folder_name_input = r'/gpfs/sharedfs1/alb16177/vap24003/OutputData/20250421_Confine_CP_all/'
folder_name_output = newpath+'/' 
folder_name_fig = folder_name_output
file_name_input = folder_name_input + file_name
SC_solution = h5py.File(file_name_input,'r+')
SC_solution.path = folder_name_input
current_folder = file_name_input

file_name_output = str(file_name_input).replace(folder_name_input+'/','')[:-15]
print(file_name_input)
print(file_name_output)

aim_folder = current_folder.replace(folder_name_input,'')
mesh_input = from_hdf5(SC_solution['solution']['device']['mesh'])

# ----------------------------------------------------- #

# Time
frameN = np.array([])
time = np.array([0])

for i in SC_solution['data']:
    frameN = np.append(frameN,int(i))
    if int(i)>0: time = np.append(time,time[int(i)-1]+SC_solution['data'][i]['running_state']['dt'][0])
time = time/max(time)*solve_time

# Mesh
voronoi_POS = SC_solution['solution']['device']['mesh']['sites']
voronoi_tri = SC_solution['solution']['device']['mesh']['elements']
Xtri = SC_solution['solution']['device']['mesh']['sites'][:,0]
Xtri = Xtri/max(Xtri)*width/2
Ytri = SC_solution['solution']['device']['mesh']['sites'][:,1]
Ytri = Ytri/max(Ytri)*height/2
Xtri_center = SC_solution['solution']['device']['mesh']['edge_mesh']['centers'][:,0]
Xtri_center = Xtri_center/max(Xtri_center)*width/2
Ytri_center = SC_solution['solution']['device']['mesh']['edge_mesh']['centers'][:,1]
Ytri_center = Ytri_center/max(Ytri_center)*height/2

# print(frameN)
plt.figure()
plt.plot(frameN, time)
# plt.plot(time)
plt.savefig(newpath+'/time_mesh.png', transparent=True, bbox_inches = "tight")

from scipy import interpolate
# from tdgl.finite_volume import mesh

mesh_n = 200
Xmax, Ymax = [width,height]
X = np.linspace(-Xmax/2,Xmax/2,mesh_n)
Y = np.linspace(-Ymax/2,Ymax/2,mesh_n)
Xv, Yv = np.meshgrid(X, Y)
Zv = np.zeros_like(Xv)
mesh_input = from_hdf5(SC_solution['solution']['device']['mesh'])

''' Done. '''

"""================================================================================="""
"""### Part 5: Calculate gradient of theta ###
====================================================================================
"""

### Calc grad_phi

from tqdm import tqdm

"""
def grad_phi(SC_solution,Xtri,Ytri,mesh_n,width,height,time):
  Xmax, Ymax = [width,height]
  X = np.linspace(-Xmax/2,Xmax/2,mesh_n)
  Y = np.linspace(-Ymax/2,Ymax/2,mesh_n)
  Xv, Yv = np.meshgrid(X, Y)
  dx, dy = X[2]-X[1], Y[2]-Y[1]
  grad_phi_x, grad_phi_y = np.zeros([mesh_n,len(time)],float), np.zeros([mesh_n,len(time)],float)
  psi_x, psi_y = np.zeros([mesh_n,len(time)],float), np.zeros([mesh_n,len(time)],float)
  psi_grad_phi_x, psi_grad_phi_y = np.zeros([mesh_n,len(time)],float), np.zeros([mesh_n,len(time)],float)
  for intti in tqdm(range(len(time))):
    ti = time[intti]
    frame_ti = findval(time,ti)
    psi_ti_re = interpolate.griddata(np.array([Xtri,Ytri]).T,
            np.real(SC_solution['data'][str(frame_ti)]['psi'][:]),(Xv, Yv), method='linear',)
    psi_ti_im = interpolate.griddata(np.array([Xtri,Ytri]).T,
            np.imag(SC_solution['data'][str(frame_ti)]['psi'][:]),(Xv, Yv), method='linear',)
    psi_cn = psi_ti_re+1j*psi_ti_im
    phase_ti = np.angle(psi_ti_re+1j*psi_ti_im)
    diffPhasex = np.zeros_like(X)
    diffPhasey = np.zeros_like(Y)
    for i in range(mesh_n):
      tempx = np.unwrap(phase_ti[:,i])
      grad_phi_x[i,intti] = tempx[-5]-tempx[5]
      psi_grad_phi_x[i,intti] = np.sum(abs(psi_cn[5:-5,i])**2*np.diff(tempx[5:-4])**2/dx)
      tempy = np.unwrap(phase_ti[i,:])
      psi_grad_phi_y[i,intti] = np.sum(abs(psi_cn[i,5:-5])**2*np.diff(tempy[5:-4])**2/dx)
      grad_phi_y[i,intti] = tempy[-5]-tempy[5]
      psi_x[i,intti] = np.sum(abs(psi_cn[5:-5,i]))
      psi_y[i,intti] = np.sum(abs(psi_cn[i,5:-5]))
  return np.array([grad_phi_x,grad_phi_y]), np.array([psi_grad_phi_x,psi_grad_phi_y]), np.array([psi_x,psi_y])

GradPhi, PsiGradPhi, tPsi = grad_phi(SC_solution,Xtri,Ytri,mesh_n,width,height,time)

plt.figure(figsize=figsize)
plt.plot(X,GradPhi[0,:,:])
plt.savefig(newpath+'/theta_scan_x.png', transparent=True, bbox_inches = "tight")
plt.figure(figsize=figsize)
plt.plot(Y,GradPhi[1,:,:])
plt.savefig(newpath+'/theta_scan_y.png', transparent=True, bbox_inches = "tight")
plt.figure(figsize=figsize)
plt.plot(X,tPsi[0,:,:])
plt.savefig(newpath+'/psi_scan_x.png', transparent=True, bbox_inches = "tight")
plt.figure(figsize=figsize)
plt.plot(Y,tPsi[1,:,:])
plt.savefig(newpath+'/psi_scan_y.png', transparent=True, bbox_inches = "tight")
plt.figure(figsize=figsize)
plt.plot(X,PsiGradPhi[0,:,:])
plt.savefig(newpath+'/psitheta_scan_x.png', transparent=True, bbox_inches = "tight")
plt.figure(figsize=figsize)
plt.plot(Y,PsiGradPhi[1,:,:])
plt.savefig(newpath+'/psitheta_scan_y.png', transparent=True, bbox_inches = "tight")

np.savetxt(newpath+'/tPsi.txt', tPsi.reshape(tPsi.shape[0], -1))
np.savetxt(newpath+'/PsiGradPhi.txt', PsiGradPhi.reshape(PsiGradPhi.shape[0], -1))
np.savetxt(newpath+'/GradPhi.txt', GradPhi.reshape(GradPhi.shape[0], -1))
np.savetxt(newpath+'/time.txt', time)
np.savetxt(newpath+'/mesh_n.txt', [mesh_n,0])
"""

dpi = 200
xi = 0.1

"""
time = np.loadtxt(newpath+'/time.txt')
mesh_n = np.loadtxt(newpath+'/mesh_n.txt')
mesh_n = int(mesh_n[0])
GradPhi = np.loadtxt(newpath+'/GradPhi.txt')
GradPhi = GradPhi.reshape((2, mesh_n, len(time)))
figsize = (10,2.5)

# ----- Save GradPhi

plt.figure(figsize=figsize)
# plt.plot(X,GradPhi[0,:,:]+np.array(range(len(time)))*5)
cmax = max([(GradPhi[0,:,:]/2/np.pi).max(), (GradPhi[1,:,:]/2/np.pi).max()])
cmap = 'jet'
plt.pcolor(time,X/xi,GradPhi[0,:,:]/2/np.pi,clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('$\\theta_{y2}-\\theta_{y1}$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$x/ \\xi_{0}$')
plt.savefig(newpath+'/dTheta_x.png', transparent=True, bbox_inches = "tight", dpi=dpi)

plt.figure(figsize=figsize)
# plt.plot(Y,GradPhi[1,:,:]+np.array(range(len(time)))*5)
plt.pcolor(time,Y/xi,GradPhi[1,:,:]/2/np.pi,clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('$\\theta_{x2}-\\theta_{x1}$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$y/ \\xi_{0}$')
plt.savefig(newpath+'/dTheta_y.png', transparent=True, bbox_inches = "tight", dpi=dpi)

np.savetxt(newpath+'/GradPhi_mean.txt', [GradPhi[0,:,:].mean(),GradPhi[1,:,:].mean()])
print('x: '+str(GradPhi[0,:,:].mean()))
print('y: '+str(GradPhi[1,:,:].mean()))

# ----- Save tPsi

plt.figure(figsize=figsize)
# plt.plot(X,tPsi[0,:,:]+np.array(range(len(time)))*5)
cmax = max([(tPsi[0,:,:]).max(), (tPsi[1,:,:]).max()])
cmap = 'plasma'
plt.pcolor(time,X/xi,tPsi[0,:,:],clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('$\\Sigma_y |\\psi|$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$x/ \\xi_{0}$')
plt.savefig(newpath+'/tPsi_x.png', transparent=True, bbox_inches = "tight", dpi=dpi)

plt.figure(figsize=figsize)
# plt.plot(Y,tPsi[1,:,:]+np.array(range(len(time)))*5)
plt.pcolor(time,Y/xi,tPsi[1,:,:],clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('$\\Sigma_x |\\psi|$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$y/ \\xi_{0}$')
plt.savefig(newpath+'/tPsi_y.png', transparent=True, bbox_inches = "tight", dpi=dpi)

# ----- Save PsiGradPhi

plt.figure(figsize=figsize)
# plt.plot(X,PsiGradPhi[0,:,:]+np.array(range(len(time)))*5)
cmax = max([(PsiGradPhi[0,:,:]).max(), (PsiGradPhi[1,:,:]).max()])
cmap = 'plasma'
plt.pcolor(time,X/xi,PsiGradPhi[0,:,:],clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('$\\Sigma_y \\rho |\\nabla \\theta_s|^2$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$x/ \\xi_{0}$')
plt.savefig(newpath+'/PsiGradPhi_x.png', transparent=True, bbox_inches = "tight", dpi=dpi)

plt.figure(figsize=figsize)
# plt.plot(Y,PsiGradPhi[1,:,:]+np.array(range(len(time)))*5)
plt.pcolor(time,Y/xi,PsiGradPhi[1,:,:],clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('$\\Sigma_x \\rho |\\nabla \\theta_s|^2$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$y/ \\xi_{0}$')
plt.savefig(newpath+'/PsiGradPhi_y.png', transparent=True, bbox_inches = "tight", dpi=dpi)

"""

cmap = 'jet'

"""================================================================================="""
"""### Part 6: Calculate Ek ###
====================================================================================
"""

"""
def v2s(x,y): return np.sqrt(x**2+y**2)

def Ugrad(psi,Ax,Ay,dx,dy):
  Ux = np.exp(-1j*Ax*dx)
  Uy = np.exp(-1j*Ay*dy)
  gx, gy = np.zeros_like(psi), np.zeros_like(psi)
  gx[1:,:] = (Ux[1:,:]*psi[1:,:]-psi[:-1,:])/dx
  gy[:,1:] = (Uy[:,1:]*psi[:,1:]-psi[:,:-1])/dy
  gx[0,:] = 2*gx[2,:]-gx[1,:]
  gy[:,0] = 2*gy[:,2]-gy[:,1]
  return gx, gy

def Ek_calc_plot(SC_solution,Xtri,Ytri,mesh_n,width,height,time,):
# if True:
### Initialization of mesh and vector potential
  Xmax, Ymax = [width,height]
  X = np.linspace(-Xmax/2,Xmax/2,mesh_n)
  Y = np.linspace(-Ymax/2,Ymax/2,mesh_n)
  dx, dy = (X[2]-X[1])/xi, (Y[2]-Y[1])/xi
  da = dx*dy
  Xv, Yv = np.meshgrid(X, Y)
  grad_phi_x, grad_phi_y = np.zeros([mesh_n,len(time)],float), np.zeros([mesh_n,len(time)],float)
  def A_(t):
    A_t = A_LG_t(Xv, Yv, np.zeros_like(Xv), t=t, w=w_input, w0=w0, E0=E0i, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss, phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s,
            tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute,
            angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units)
    Ax = np.squeeze(A_t[:,0,:])
    Ay = np.squeeze(A_t[:,1,:])
    return Ax, Ay
  t_print = [0,100,200,300,400,500]
  figsize = (5.5,2)

### Initialization of output parameters
  E_A_rec = np.zeros_like(time)
  E_psi_rec = np.zeros_like(time)
  E_k_rec = np.zeros_like(time)
  E_J_tdgl_rec = np.zeros_like(time)
  E_J_eq_rec = np.zeros_like(time)
  Psi_sum_rec = np.zeros_like(time)
  E_pot_rec = np.zeros_like(time)
    
### Initialization of output parameters
  for intti in tqdm(range(len(time))):
  # ti = 100
  # if ti==100:
    ti = time[intti]
    # intti = 0
    frame_ti = findval(time,ti)
    Ax, Ay = A_(ti)
    psi_raw = SC_solution['data'][str(frame_ti)]['psi'][:]
    psi_ti_re = interpolate.griddata(np.array([Xtri,Ytri]).T,
            np.real(psi_raw),(Xv, Yv), method='linear',)
    psi_ti_im = interpolate.griddata(np.array([Xtri,Ytri]).T,
            np.imag(psi_raw),(Xv, Yv), method='linear',)
    psi_cn = psi_ti_re + 1j*psi_ti_im
    psi_cj = psi_ti_re - 1j*psi_ti_im
    phase_ti = np.angle(psi_ti_re+1j*psi_ti_im)
    Js_ti = interpolate.griddata(np.array([Xtri,Ytri]).T,
            get_J(SC_solution,mesh_input,'s',str(frame_ti)),(Xv, Yv), method='linear',)
    grad_px, grad_py = np.gradient(psi_cn, dy, dx) # xi=0.1
    grad_pxx, grad_pyx = np.gradient(grad_px, dy, dx)
    grad_pxy, grad_pyy = np.gradient(grad_py, dy, dx)
    grad_Ax, grad_Ay_ = np.gradient(Ax, dy, dx)
    grad_Ax_, grad_Ay = np.gradient(Ay, dy, dx)
    E_A = abs(1j*(v2s(Ax*psi_cn, Ay*psi_cn)))**2/2
    E_psi = abs(grad_pxx+grad_pyy)/2 # https://numpy.org/doc/2.1/reference/generated/numpy.gradient.html
    E_k = abs(grad_pxx+grad_pyy-1j*Ax*grad_px-1j*Ay*grad_py-1j*grad_Ax*psi_cn-1j*grad_Ay*psi_cn-Ax**2-Ay**2)/2
    # https://numpy.org/doc/2.1/reference/generated/numpy.gradient.html
    gx, gy = Ugrad(psi_cn,Ax*0,Ay*0,(X[2]-X[1])/0.1,(Y[2]-Y[1])/0.1)
    Js2_ti = v2s(np.imag(np.conj(psi_cn)*gx), np.imag(np.conj(psi_cn)*gy))
    E_J_tdgl = Js_ti**2/2/abs(psi_cn)**2
    E_J_eq = Js2_ti**2/2/abs(psi_cn)**2
    Psi_sum = abs(psi_cn)
    Psi_sum2 = abs(psi_cn)**2
    Psi_sum4 = abs(psi_cn)**4

    ## Save data
    E_A_rec[intti] = E_A[5:-5,5:-5].sum()*da
    E_psi_rec[intti] = E_psi[5:-5,5:-5].sum()*da
    E_k_rec[intti] = E_k[5:-5,5:-5].sum()*da
    E_J_tdgl_rec[intti] = E_J_tdgl[5:-5,5:-5].sum()*da
    E_J_eq_rec[intti] = E_J_eq[5:-5,5:-5].sum()*da
    Psi_sum_rec[intti] = Psi_sum.sum()*da
    E_pot_rec[intti] = -Psi_sum2.sum()*da+Psi_sum4.sum()/2*da
    
    for ti_plot in t_print:
      if frame_ti==findval(time,ti_plot):
        np.savetxt(newpath+'/psi_cn_t'+str(ti_plot)+'.txt', psi_cn)
        np.savetxt(newpath+'/phase_t'+str(ti_plot)+'.txt', phase_ti)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_A,cmap=cmap)
        plt.colorbar()
        plt.title('$E_A$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_A_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        np.savetxt(newpath+'/E_A_t'+str(ti_plot)+'.txt', E_A)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_psi,cmap=cmap)
        plt.colorbar()
        plt.title('$E_{\\Delta \\psi}$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_psi_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        np.savetxt(newpath+'/E_psi_t'+str(ti_plot)+'.txt', E_psi)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_k,cmap=cmap)
        plt.colorbar()
        plt.title('$E_k$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_k_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        np.savetxt(newpath+'/E_k_t'+str(ti_plot)+'.txt', E_k)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_J_tdgl,cmap=cmap)
        plt.colorbar()
        plt.title('$E_J$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_J_tdgl_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        np.savetxt(newpath+'/E_J_tdgl_t'+str(ti_plot)+'.txt', E_J_tdgl)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_J_eq,cmap=cmap)
        plt.colorbar()
        plt.title('$E_J$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_J_eq_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)

        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_k-E_A,cmap=cmap)
        plt.colorbar()
        plt.title('$E_k-E_A$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_k1_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)

        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,E_k-E_J_eq,cmap=cmap)
        plt.colorbar()
        plt.title('$E_k-E_J$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/E_k2_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,Js_ti,cmap=cmap)
        plt.colorbar()
        plt.title('$J_s(t)$')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/Js1_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        np.savetxt(newpath+'/Js1_t'+str(ti_plot)+'.txt', Js_ti)
        
        plt.figure(figsize=figsize)
        plt.pcolor(X/xi,Y/xi,v2s(np.imag(np.conj(psi_cn)*(grad_px-1j*Ax*psi_cn)), np.imag(np.conj(psi_cn)*(grad_py-1j*Ay*psi_cn))),cmap=cmap)
        plt.colorbar()
        plt.title('$J_s(t)$ (Eq)')
        plt.xlabel('$x/ \\xi_0$')
        plt.ylabel('$y/ \\xi_0$')
        plt.savefig(newpath+'/Js2_t'+str(ti_plot)+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
        np.savetxt(newpath+'/Js2_t'+str(ti_plot)+'.txt', v2s(np.imag(np.conj(psi_cn)*(grad_px-1j*Ax*psi_cn)), np.imag(np.conj(psi_cn)*(grad_py-1j*Ay*psi_cn))))

  np.savetxt(newpath+'/E_A.txt', E_A_rec)
  np.savetxt(newpath+'/E_psi.txt', E_psi_rec)
  np.savetxt(newpath+'/E_k.txt', E_k_rec)
  np.savetxt(newpath+'/E_J_tdgl.txt', E_J_tdgl_rec)
  np.savetxt(newpath+'/E_J_eq.txt', E_J_eq_rec)
  np.savetxt(newpath+'/Psi_sum_rec.txt', Psi_sum_rec)
  np.savetxt(newpath+'/E_pot_rec.txt', E_pot_rec)
  return E_A_rec, E_psi_rec, E_k_rec, E_J_tdgl_rec, E_J_eq_rec, Psi_sum_rec, E_pot_rec


E_A, E_psi, E_k, E_J_tdgl, E_J_eq, Psi_sum, E_pot = Ek_calc_plot(SC_solution,Xtri,Ytri,mesh_n,width,height,time,)

### Figure of Ek

def plot_figures(x,y,title,xlabel,ylabel,figname,dpi):
  plt.figure(figsize=figsize)
  plt.plot(x,y)
  plt.title(title)
  plt.xlabel(xlabel)
  plt.ylabel(ylabel)
  plt.savefig(newpath+'/'+figname+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
labelx, labely = '$t/ \\tau_{GL}$', 'Energy (a.u.)'
plot_figures(time,E_A,'$E_A$',labelx,labely,'E_A_trace',dpi)
plot_figures(time,E_psi,'$E_{\\Delta \\psi}$',labelx,labely,'E_psi_trace',dpi)
plot_figures(time,E_k,'$E_k$',labelx,labely,'E_k_trace',dpi)
plot_figures(time,E_J_tdgl,'$E_J$',labelx,labely,'E_J_tdgl_trace',dpi)
plot_figures(time,E_J_eq,'$E_J$',labelx,labely,'E_J_eq_trace',dpi)
plot_figures(time,Psi_sum,'$\\Sigma $|$\\psi$|',labelx,labely,'PSi_sum_trace',dpi)
plot_figures(time,E_pot,'$E_{pot}$',labelx,labely,'E_pot_trace',dpi)

### FFT of Ek

from scipy.fft import fft, fftfreq, fftshift

def plot_figures_FFT(x,y,title,xlabel,ylabel,figname,dpi):
  xFT = fftfreq(len(x),x[2]-x[1])
  yFT = fft(fftshift(y))
  plt.figure(figsize=figsize)
  plt.plot(xFT[2:-2],yFT[2:-2])
  plt.title(title)
  plt.xlabel(xlabel)
  plt.ylabel(ylabel)
  plt.xlim([0,0.5])
  plt.savefig(newpath+'/'+figname+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
labelx, labely = '$\\omega/ \\omega_{GL}$', 'Intensity (a.u.)'
plot_figures_FFT(time,E_A,'$E_A$',labelx,labely,'E_A_FFT',dpi)
plot_figures_FFT(time,E_psi,'$E_{\\Delta \\psi}$',labelx,labely,'E_psi_FFT',dpi)
plot_figures_FFT(time,E_k,'$E_k$',labelx,labely,'E_k_FFT',dpi)
plot_figures_FFT(time,E_J_tdgl,'$E_J$',labelx,labely,'E_J_tdgl_FFT',dpi)
plot_figures_FFT(time,E_J_eq,'$E_J$',labelx,labely,'E_J_eq_FFT',dpi)

print('Ek analysis: done.')

"""

"""================================================================================="""
"""### Part 7: Output Time frames ###
====================================================================================
"""

 ### Part 7-1: Scan Max values ###

from matplotlib.ticker import MaxNLocator, MultipleLocator
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.optimize import curve_fit
from matplotlib.gridspec import GridSpec 
import matplotlib as mpl
from scipy import interpolate
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
new_cbar = cm.get_cmap("bwr", 100)
K0 = 2.095153729869544

def scan_value(num):
    ti_show = np.linspace(0, time.max(), num=num)
    # ti_show = np.linspace(0, time.max(), num=41) # test

    X = np.linspace(-width/2,width/2,quiver_mesh_n)
    Y = np.linspace(-height/2,height/2,quiver_mesh_n)
    Xv, Yv = np.meshgrid(X, Y)
    dx, dy = [X[2]-X[1], Y[2]-Y[1]]

    px = findval(X,0)
    py = findval(Y,0)
    # ptri = find_index(POStrack[POSi,:],np.array([Xtri,Ytri]).T)
    psi_plot = np.zeros([len(Y),len(ti_show)])
    phase_plot = np.zeros([len(Y),len(ti_show)])
    vor_plot = np.zeros([len(Y),len(ti_show)])
    J_plot = np.zeros([len(Y),len(ti_show)])
    PhiB_plot = np.zeros(len(ti_show))


    for ti in tqdm(ti_show):
        frame_ti = findval(time,ti)
        psi_interp = interpolate.griddata(np.array([Xtri,Ytri]).T,
                    np.abs(SC_solution['data'][str(frame_ti)]['psi']),(Xv, Yv), method='cubic',)
        phase_interp = interpolate.griddata(np.array([Xtri,Ytri]).T,
                    np.angle(SC_solution['data'][str(frame_ti)]['psi']),(Xv, Yv), method='cubic',)
        vorticity_ti = interpolate.griddata(np.array([Xtri,Ytri]).T,
                    get_vorticity(SC_solution,mesh_input,"vorticity",str(frame_ti)),(Xv, Yv), method='linear',)
        J_ti = interpolate.griddata(np.array([Xtri,Ytri]).T,
                    get_J(SC_solution,mesh_input,"Js+Jn",str(frame_ti)),(Xv, Yv), method='linear',)
        psi_plot[:,findval(ti_show,ti)] = np.array(psi_interp[:,px])
        phase_plot[:,findval(ti_show,ti)] = np.array(phase_interp[:,px])
        vor_plot[:,findval(ti_show,ti)] = np.array(vorticity_ti[:,px])
        J_plot[:,findval(ti_show,ti)] = np.array(J_ti[:,px])
        E_x, E_y = E_input_frame(Xv,Yv,ti,take_real=False)
        B_x, B_y, B_z = E2Bv(Xv,Yv,E0i*E_x,E0i*E_y,constant_Bz,c,w_input)
        PhiB_plot[findval(ti_show,ti)] = np.sum(np.sum(abs(np.real(B_z))/2*dx*dy))

    mag_cmap = "gnuplot"#"viridis"
    phase_cmap = "BrBG"#"twilight_shifted"
    vorticity_cmap = "bwr"
    J_cmap = "inferno"
    # rset = np.linspace(0, 1, 100)
    # vorticity_cmap = ListedColormap((new_cbar(rset))**1.5)#"bwr"
    shading = "gouraud"
    psi_label = "$|\\psi|$"
    phase_label = "$\\theta_s / \\pi$"
    vorticity_label = "$\\omega_{v,s}$"
    J_label = "$J/J_0$"
    dpi = 800

    plt.rcParams.update({'font.serif': 'Times New Roman',
                                    'font.size': 10.0,
                                    'axes.labelsize': 'Medium',
                                    'axes.labelweight': 'normal',
                                    'axes.linewidth': 0.8,
                                     ###########################################
                                     # THIS IS THE IMPORTANT ONE FOR STRETCHING
                                     # default is [6,4] but...i changed it to
                                    'figure.figsize':[15,5]   # THIS ONE #
                                  })

    xi = xi_coherent.magnitude
    X_curve, Y_curve = np.meshgrid(ti_show, Y/xi)

    # -------------------------------------- Fig set

    ## Figures

    # Creates a 2 row, 1 column plot that shares the x-axis
    fig, ax = plt.subplots(5,1, figsize=(10,6.5), sharex=True, dpi=dpi,  height_ratios = [1, 3, 3, 3, 3])#, constrained_layout=True)
    style_set = ['-','--','-.',]
    # Set the spaceing between plots to zero
    plt.subplots_adjust(hspace=0)
     # Get color list from physrev.mplstyle for selecting colors for plot
    # for matplotlib <= 1.5.x
    color = [u'#1f77b4', u'#ff7f0e', u'#2ca02c', u'#d62728', u'#9467bd', u'#8c564b', u'#e377c2', u'#7f7f7f', u'#bcbd22', u'#17becf']

    ## Plot 1

    ax1 = ax[0]
    color = 'gray'
    # ax1.set_xlabel('Time ($\\tau_{GL}$)')
    ax1.set_ylabel('$E_{x}$', color=color)
    ax1.plot(time, 1*np.cos(time*w_input), color=color)
    ax1.tick_params(axis='y', labelcolor=color)
    ax1.set_ylim([-1.99,1.4])

    # ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
    # color = 'gray'
    # ax2.set_ylabel('$A_{x}$', color=color)  # we already handled the x-label with ax1
    # ax2.plot(time, -1*np.sin(time*w_input), color=color)
    # ax2.tick_params(axis='y', labelcolor=color)
    # ax2.set_ylim([-1.99,1.4])

    # for Nti in range(int(solve_time*w_input/2/np.pi)+1): ax1.axvline(x=(Nti)*(2*np.pi/w_input),color='k',linestyle='dashed',linewidth=0.5)

     ## Plot 2

    ax1 = ax[1]
    Z_curve = np.copy(psi_plot)
    ax1.pcolor(X_curve,Y_curve,Z_curve,cmap=mag_cmap,vmin=0,vmax=1)
    ax1.set_ylabel('$x/\\xi$')
    # ax1.legend(frameon=False,loc="center",ncol=3)
    ax1.set_ylim([Y_curve.min(),Y_curve.max()])
    ax1.yaxis.set_major_locator(MaxNLocator(prune='upper'))
    majors = [-20, -10, 0, 10, 20, 30]
    ax1.yaxis.set_major_locator(ticker.FixedLocator(majors))
    ax1.text(2,-17,psi_label,fontsize=12)

    # ax1.plot([3,3],[-0.4/xi,0.4/xi],'--',color="c",lw=0.8)
    # ax1.plot([3-1,3+1],[0.4/xi,0.4/xi],'-',color="c",lw=0.8)
    # ax1.plot([3-1,3+1],[-0.4/xi,-0.4/xi],'-',color="c",lw=0.8)
    # ax1.text(5,3,'$2w_0$',fontsize=9,color='k')

    # for Nti in range(int(solve_time*w_input/2/np.pi)+1): ax1.axvline(x=(Nti)*(2*np.pi/w_input),color='k',linestyle='dashed',linewidth=0.5)

    # ti_set = np.array([65.0,70.0,75.0,80.5,82.5])
    # for ti in ti_set:
    #     ax1.plot([ti,ti],[-0.4/xi,0.4/xi],'--',color="c",lw=0.8)
    #     ax1.text(ti-0.5,(+5.3)*(+1)**(findval(ti_set,ti)+1),'$\\tau_{'+str(findval(ti_set,ti)+1)+'}$',fontsize=9,color='k')

    ## Plot 3

    Z_curve = np.copy(phase_plot)/np.pi
    ax1 = ax[2]
    ax1.pcolor(X_curve,Y_curve,Z_curve,cmap=phase_cmap,vmin=-1,vmax=1)
    ax1.set_ylim([Y_curve.min(),Y_curve.max()])
    # for Nti in range(int(solve_time*w_input/2/np.pi)+1): ax1.axvline(x=(Nti)*(2*np.pi/w_input),color='k',linestyle='dashed',linewidth=0.5)
    ax1.set_ylabel('$x/\\xi$')
    majors = [-20, -10, 0, 10, 20, 30]
    ax1.yaxis.set_major_locator(ticker.FixedLocator(majors))
    ax1.text(2,-17,phase_label,color='k',fontsize=12)

    ## Plot 4

    Z_curve = np.copy(J_plot)/K0
    Z_curve[:,-1] = Z_curve[:,-1]*0
    ax1 = ax[3]
    ax1.pcolor(X_curve,Y_curve,Z_curve,cmap=J_cmap,vmin=0,vmax=0.150)
    ax1.set_ylim([Y_curve.min(),Y_curve.max()])
    # for Nti in range(int(solve_time*w_input/2/np.pi)+1): ax1.axvline(x=(Nti)*(2*np.pi/w_input),color='k',linestyle='dashed',linewidth=0.5)
    ax1.set_ylabel('$x/\\xi$')
    majors = [-20, -10, 0, 10, 20, 30]
    ax1.yaxis.set_major_locator(ticker.FixedLocator(majors))
    ax1.text(2,-17,J_label,fontsize=12,color='white')

    ax1.set_xlim([0,time.max()])

    ## Plot 5

    Z_curve = np.copy(vor_plot)
    Z_curve[:,-1] = Z_curve[:,-1]*0
    ax1 = ax[4]
    ax1.pcolor(X_curve,Y_curve,Z_curve/Z_curve.max(),cmap=vorticity_cmap,vmin=-1,vmax=1)
    ax1.set_ylim([Y_curve.min(),Y_curve.max()])
    # for Nti in range(int(solve_time*w_input/2/np.pi)+1): ax1.axvline(x=(Nti)*(2*np.pi/w_input),color='k',linestyle='dashed',linewidth=0.5)
    ax1.set_ylabel('$x/\\xi$')
    majors = [-20, -10, 0, 10, 20, 30]
    ax1.yaxis.set_major_locator(ticker.FixedLocator(majors))
    ax1.text(2,-17,vorticity_label,fontsize=12)

    ax1.set_xlabel('Time ($\\tau_{GL}$)')
    ax1.set_xlim([0,time.max()])

    return psi_plot, phase_plot, vor_plot, J_plot, PhiB_plot, fig

psi_plot, phase_plot, vor_plot, J_plot, PhiB_plot, fig = scan_value(251)
fig.show()

figname = 'scan_max'
plt.savefig(newpath+'/'+figname+'.png', transparent=True, bbox_inches = "tight", dpi=dpi)
fig.clf()


print(J_plot.max())
print(vor_plot.max())

''' Done! '''

### Part 7-2: Output Time frame ###

### Make Animetion
Xtri = SC_solution['solution']['device']['mesh']['sites'][:,0]
Xtri = Xtri/max(Xtri)*6/2
Ytri = SC_solution['solution']['device']['mesh']['sites'][:,1]
Ytri = Ytri/max(Ytri)*4/2
### Build-up subplot

from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
import matplotlib.font_manager as fm
from matplotlib.gridspec import GridSpec
import matplotlib.transforms as mtrans
import os
# import time

def get_J_xy(
    h5file: h5py.File,
    mesh,
    quantity: Quantity,
    frame: int,
    Jmax: float=0.2,
):
    """Get data to plot.

    Args:
        h5file: The data file.
        mesh: The mesh used in the simulation.
        quantity: The quantity to return.
        frame: The current frame.

    Returns:
        A tuple of the values for the color plot, the directions for the
        quiver plot and the limits for the color plot.
    """
    tdgl_data = TDGLData.from_hdf5(h5file, frame)
    psi = tdgl_data.psi
    mu = tdgl_data.mu
    epsilon = tdgl_data.epsilon
    a_applied = tdgl_data.applied_vector_potential
    a_induced = tdgl_data.induced_vector_potential
    supercurrent = tdgl_data.supercurrent
    normal_current = tdgl_data.normal_current
    nsites = len(mesh.sites)
    j_sc_site = mesh.get_quantity_on_site(supercurrent)
    j_nm_site = mesh.get_quantity_on_site(normal_current)

    if quantity=='n': j_site = j_nm_site
    elif quantity=='s': j_site = j_sc_site
    else: j_site = j_sc_site + j_nm_site
    J = np.sqrt(j_site[:, 0]**2 + j_site[:, 1]**2)
    Jxnorm = j_site[:, 0]/Jmax
    Jynorm = j_site[:, 1]/Jmax

    return J, Jxnorm, Jynorm #, np.zeros((nsites, 2)), [-vmax, vmax]

if not os.path.exists(newpath+'/fig_anime/'): os.makedirs(newpath+'/fig_anime/')
folder_name = newpath+'/fig_anime/'

dpi=200
fps=20
# solve_time = 40
save_frame = 1
max_frame = 501#int(len(time)/save_frame)
frame_set = np.arange(max_frame)*save_frame
frame_set = frame_set[0:]

iniframe = frame_set[0]

# ti_set = [1,2,3]

ti_set = np.linspace(0, 500, num=501)
# ti_set = np.linspace(100, 200, num=101)
# ti_set = np.linspace(200, 300, num=101)
# ti_set = np.linspace(300, 400, num=101)
# ti_set = np.linspace(400, 500, num=101)
# HHHHHHHHHHeeeeeeeeyyyyyyyyy !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Revise here !!!!!!!!!!!!!!!!!1
print('Time start: '+str(min(ti_set)))
print('Time end: '+str(max(ti_set)))
frame_set = np.copy(ti_set)

init = min(ti_set)

Parameter_set = frame_set # ti_set
K0 = 2.095153729869544

# f, axes  = plt.subplots(nrows=3, ncols=len(Parameter_set), sharey=True, sharex=True, figsize=(10,5), dpi=dpi, height_ratios = [0.8, 3, 3]) # constrained_layout=True,
circle = plt.Circle((0, 0), w0/xi, color='c',fill=False,linestyle='--')

mag_cmap = "gnuplot"#"viridis"
phase_cmap = "BrBG"#"twilight_shifted"
vorticity_cmap = "bwr"
j_cmap = 'inferno'
cmap_all = [' ',mag_cmap, phase_cmap, j_cmap, vorticity_cmap, ' ', "PRGn"]
vmin_all = [  0,       0,        -1,       0,             -1,   0,    -9.4]
vmax_all = [  1,       1,         1,    1,              1,   1,     9.4]
# rset = np.linspace(0, 1, 100)
# vorticity_cmap = ListedColormap((new_cbar(rset))**1.5)#"bwr"

psi_label = "$|\\psi|$"
phase_label = "$\\theta_s / \\pi$"
vorticity_label = "$\\omega_{v,s}$"
j_label = "Norm. $J$"
label_all = [' ', psi_label, phase_label, j_label, vorticity_label,'$E$','$B_z/B_{c2}$']
labelfontsize = 12
labelcolor_all = [' ', 'k', 'k', 'white', 'k', 'k', 'k']

MAKE_ANIMATIONS = True
if MAKE_ANIMATIONS:

# Basic sattings
    input_file = SC_solution
    shading = "gouraud"
    # fps = 10
    # dpi= 100
    max_cols = 6
    min_frame = 0
    max_frame = -1
    autoscale = False
    dimensionles = False
    xlim = [(Xtri/xi).min(), (Xtri/xi).max()]
    ylim = [(Ytri/xi).min(), (Ytri/xi).max()]
    axis_labels = False
    axes_off = False
    title_off = False
    full_title = True
    logger = None
    figure_kwargs = None
    writer = None
    quiver_scale = 1
    quiver_mesh_n = 20
    width_quiver = 0.08
    dimensionless = False
    # quantities = ("order_parameter", "phase")
    # output_file = folder_name+'/'+'SI4'+"_video.mp4"

    def timescan(frame):
        yout = np.ones_like(time_perform)*(-2)
        yout[frame] = 2
        return yout

    for num_set_read in tqdm(frame_set):
            
            # create objects
            fig = plt.figure(constrained_layout=True, figsize=(10,6), dpi=dpi)
            gs = GridSpec(3, 2, figure=fig, height_ratios = [0.6, 4, 4], width_ratios = [1, 1])
            
            # create sub plots as grid
            ax = {}
            ax[0] = fig.add_subplot(gs[0, 0:])
            ax[0].tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)
            
            
            time_perform = np.arange(501.0)
            ax1 = ax[0]
            color = 'gray'
            # ax1.set_xlabel('$t/ \\tau_{GL}$')
            # ax1.set_ylabel('$E_{x}$', color=color)
            ax1.plot(ti_set, 1*np.cos(ti_set*w_input), color=color, alpha=0.5, label='norm($E_x$)')
            # ax1.tick_params(axis='y', labelcolor=color)
            ax1.set_ylim([-1.4,1.4])
            ax1.set_xlim([0,solve_time])
            ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))
            ax1.set_yticks([-1,1])
            Ic = 1.5
            ax1.set_title('$E_0$: '+str(int(E0i*10)/10)+', $I$: '+str(int(current_amp/Ic*10)/10))
            # left, bottom, width, height = (0, -2, time[iniframe], 4)
            left, bottom, width, height = (0, -2, num_set_read, 4)
            rect = plt.Rectangle((left, bottom), width, height,
                                 facecolor="green", alpha=1)
            ax1.add_patch(rect)
            for Nti in range(int(solve_time*w_input/2/np.pi)+1): ax1.axvline(x=(Nti)*(2*np.pi/w_input),color='g',linestyle='dashed',linewidth=0.5)
            
            ax[1] = fig.add_subplot(gs[1, 0])
            ax[2] = fig.add_subplot(gs[1, 1])
            ax[3] = fig.add_subplot(gs[-1, 0])
            ax[4] = fig.add_subplot(gs[-1, 1])
            
            
            collections = []
            height_SC = 4
            width_SC = 6
            w0 = 0.75
            X = np.linspace(-width_SC/2,width_SC/2,quiver_mesh_n)
            Y = np.linspace(-height_SC/2,height_SC/2,quiver_mesh_n)
            Xv, Yv = np.meshgrid(X, Y)

            # num_set = 1 # Change here for test !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ti_arg = findval(time,num_set_read)
            num_set = findval(time,num_set_read)
            ti = dict(input_file['data'][str(num_set)].attrs)['time']
            Nti = findval(time,ti)
            psi = np.copy((SC_solution['data'][str(ti_arg)]['psi'][:]))
            K0 = 2.095153729869544
            J, Jxnorm, Jynorm = get_J_xy(SC_solution,mesh_input,"s+n",str(num_set),Jmax=J_plot.max())
            # J = get_J(SC_solution,mesh_input,"s",str(num_set))
            vorticity = get_vorticity(SC_solution,mesh_input,"vorticity",str(num_set))
            Jx = interpolate.griddata(np.array([Xtri,Ytri]).T, Jxnorm,(Xv, Yv), method='linear',)
            Jy = interpolate.griddata(np.array([Xtri,Ytri]).T, Jynorm,(Xv, Yv), method='linear',)

            axn = ax[0]
            axn.plot(time_perform, timescan(int(num_set_read)), color='green')
            # collections.append(collection)

            for i in range(1,5):

                if i==1: Z_value = np.abs(psi)
                if i==2: Z_value = np.angle(psi) / np.pi
                if i==3: Z_value = np.copy(J)/J_plot[10:-10,10:-10].max() #K0
                if i==4: Z_value = np.copy(vorticity)/abs(vor_plot[10:-10,10:-10].max())
                cmap = str(np.copy(cmap_all[i]))
                label = str(np.copy(label_all[i]))
                vmax = np.copy(vmax_all[i])
                vmin = np.copy(vmin_all[i])
                labeltextcolor = str(np.copy(labelcolor_all[i]))

                axn = ax[i]
                collection = axn.tripcolor(
                        Xtri/xi,
                        Ytri/xi,
                        Z_value,
                        triangles=mesh_input.elements,
                        shading=shading,
                        cmap=cmap,
                        vmin=vmin,
                        vmax=vmax,
                    )
                
                cbar = fig.colorbar(collection, ax=axn, location='top')#,extend='max')
                if i==3: axn.streamplot(Xv/xi, Yv/xi, Jx, Jy, color="white", density=1, linewidth=0.5,arrowsize=0)
                if i==3: axn.streamplot(Xv/xi, Yv/xi, Jx, Jy, color="white", density=0.3, linewidth=0.5)
                # cbar.set_label(opts.clabel)
                axn.set_aspect(0.75)
                axn.set_xlim(xlim)
                axn.set_ylim(ylim)
                axn.set_xticks([])
                axn.set_yticks([])
                # if num_set==iniframe:
                #   if int(i)==1: axn.text(28,-18,'$2\\xi$', fontsize=9)
                fontprops = fm.FontProperties(size=4, family='monospace')
                # scalebar = AnchoredSizeBar(axn.transData,
                #                 5, '            ', 'lower right',
                #                 pad=0.15,
                #                color=labeltextcolor,
                #                frameon=False,
                #                size_vertical=.1,fontproperties=fontprops)
                # axn.add_artist(scalebar)
                # axn.text(-27,16,label, fontsize=labelfontsize, color=labeltextcolor)
                axn.plot([max(X)*0.7/xi,max(X)*0.7/xi+5],[-max(Y)*0.8/xi,-max(Y)*0.8/xi],'k',lw=2,)
                axn.text(-max(X)*0.95/xi,max(Y)*0.8/xi,label, fontsize=labelfontsize, color=labeltextcolor)
                # collections.append(collection)
                # time.sleep(0.1)
                
            plt.savefig(folder_name+'/'+str(int(num_set_read))+'.png')
            fig.clf()
            # time.sleep(1)
    
    


''' Done. '''


### Part 8: Correlation function ###

### Functions

# Correlation functions

"""
# def PhaseOrder(phi,phi0): return np.cos(phi0-phi)
def PhaseOrder(phi,phi0): return np.exp(1j*(phi0-phi))
def AmplitudeOrder(psi,psi0): return abs(psi)*abs(psi0)   
def Correlation(Xv,Yv,val,func):
    lx, ly = len(Xv.T), len(Xv)
    Corr = np.zeros([val.shape[0],val.shape[1],2])
    Corr_r = np.ones_like(Corr)
    x0, y0 = Xv[0,0], Yv[0,0]
    rho_r0 = np.sqrt((Xv-x0)**2+(Yv-y0)**2)
    for ny in tqdm(range(ly)):
        for nx in range(lx):
            Corr_r[:,:,0] = func(val,val[ny,nx])
            x0, y0 = Xv[ny,nx], Yv[ny,nx]
            Corr[:(ly-ny),:(lx-nx),:] = Corr[:(ly-ny),:(lx-nx),:] + Corr_r[ny:,nx:,:] # 4th quadrant
            Corr[:(ly-ny),1:nx+1,:] = Corr[:(ly-ny),1:nx+1,:] + np.flip(Corr_r[ny:,:nx,:],axis=1) # 3rd quadrant
            Corr[1:ny+1,:(lx-nx),:] = Corr[1:ny+1,:(lx-nx),:] + np.flip(Corr_r[:ny,nx:,:],axis=0) # 1st quadrant
            Corr[1:ny+1,1:nx+1,:] = Corr[1:ny+1,1:nx+1,:] + np.flip(np.flip(Corr_r[:ny,:nx,:],axis=0),axis=1) # 2nd quadrant
    rho_output = np.unique(np.sort(rho_r0,axis=None))
    Corr_output = np.zeros_like(rho_output)
    for ni in range(len(rho_output)):
        Corr_where = Corr[:,:,0][np.where(rho_r0==rho_output[ni])]
        N_where = Corr[:,:,1][np.where(rho_r0==rho_output[ni])]
        Corr_output[ni] = Corr_where.sum()/N_where.sum()
    return rho_output, Corr_output

def Correlation_2vals(Xv,Yv,val1,val2,func1,func2):
    lx, ly = len(Xv.T), len(Xv)
    Corr1 = np.zeros([val1.shape[0],val1.shape[1],2])
    Corr_r1 = np.ones_like(Corr1)
    Corr2 = np.zeros([val2.shape[0],val2.shape[1],2])
    Corr_r2 = np.ones_like(Corr2)
    x0, y0 = Xv[0,0], Yv[0,0]
    rho_r0 = np.sqrt((Xv-x0)**2+(Yv-y0)**2)
    for ny in range(ly):
        for nx in range(lx):
            x0, y0 = Xv[ny,nx], Yv[ny,nx]
            Corr_r1[:,:,0] = func1(val1,val1[ny,nx])            
            Corr1[:(ly-ny),:(lx-nx),:] = Corr1[:(ly-ny),:(lx-nx),:] + Corr_r1[ny:,nx:,:] # 4th quadrant
            Corr1[:(ly-ny),1:nx+1,:] = Corr1[:(ly-ny),1:nx+1,:] + np.flip(Corr_r1[ny:,:nx,:],axis=1) # 3rd quadrant
            Corr1[1:ny+1,:(lx-nx),:] = Corr1[1:ny+1,:(lx-nx),:] + np.flip(Corr_r1[:ny,nx:,:],axis=0) # 1st quadrant
            Corr1[1:ny+1,1:nx+1,:] = Corr1[1:ny+1,1:nx+1,:] + np.flip(np.flip(Corr_r1[:ny,:nx,:],axis=0),axis=1) # 2nd quadrant
            Corr_r2[:,:,0] = func2(val2,val2[ny,nx])            
            Corr2[:(ly-ny),:(lx-nx),:] = Corr2[:(ly-ny),:(lx-nx),:] + Corr_r2[ny:,nx:,:] # 4th quadrant
            Corr2[:(ly-ny),1:nx+1,:] = Corr2[:(ly-ny),1:nx+1,:] + np.flip(Corr_r2[ny:,:nx,:],axis=1) # 3rd quadrant
            Corr2[1:ny+1,:(lx-nx),:] = Corr2[1:ny+1,:(lx-nx),:] + np.flip(Corr_r2[:ny,nx:,:],axis=0) # 1st quadrant
            Corr2[1:ny+1,1:nx+1,:] = Corr2[1:ny+1,1:nx+1,:] + np.flip(np.flip(Corr_r2[:ny,:nx,:],axis=0),axis=1) # 2nd quadrant
    rho_output = np.unique(np.sort(rho_r0,axis=None))
    Corr1_output = np.zeros_like(rho_output)
    Corr2_output = np.zeros_like(rho_output)
    for ni in range(len(rho_output)):
        Corr1_where = Corr1[:,:,0][np.where(rho_r0==rho_output[ni])]
        Corr2_where = Corr2[:,:,0][np.where(rho_r0==rho_output[ni])]
        N_where = Corr1[:,:,1][np.where(rho_r0==rho_output[ni])]
        Corr1_output[ni] = Corr1_where.sum()/N_where.sum()
        Corr2_output[ni] = Corr2_where.sum()/N_where.sum()
    return rho_output, Corr1_output, Corr2_output

''' Examples
rho1, C_phi = Correlation(Xv,Yv,phase,PhaseOrder)
rho2, C_amp = Correlation(Xv,Yv,psi,AmplitudeOrder)
'''

### Calculation

mesh_n = 200
xi_0 = 0.1
X = np.linspace(-Xmax/2,Xmax/2,mesh_n)
Y = np.linspace(-Ymax/2,Ymax/2,mesh_n)
dx, dy = (X[2]-X[1])/xi, (Y[2]-Y[1])/xi
da = dx*dy
Xv, Yv = np.meshgrid(X, Y)
rho_norm = np.arange(0,np.sqrt(Xmax**2+Ymax**2),0.1)

ti_set = np.copy(time)
# ti_set = [1,4,8]
cut_pt = 0
count = 0
C_psi_interp = np.zeros([len(rho_norm),len(time)])
C_phi_interp = np.zeros([len(rho_norm),len(time)])

for Nt, ti in enumerate(time): #range(len(time)):
    frame_ti = findval(time,ti)
    psi_ti = interpolate.griddata(np.array([Xtri,Ytri]).T,
            abs(SC_solution['data'][str(frame_ti)]['psi'][:]),(Xv, Yv), method='linear',)
    phase_ti = interpolate.griddata(np.array([Xtri,Ytri]).T,
            np.angle(SC_solution['data'][str(frame_ti)]['psi'][:]),(Xv, Yv), method='linear',)
    # rho1, C_phi = Correlation(Xv[cut_pt:-cut_pt],Yv[cut_pt:-cut_pt],phase_ti[cut_pt:-cut_pt],PhaseOrder)
    # rho2, C_amp = Correlation(Xv[cut_pt:-cut_pt],Yv[cut_pt:-cut_pt],psi_ti[cut_pt:-cut_pt],AmplitudeOrder))
    rho, C_amp, C_phi = Correlation_2vals(Xv,Yv,psi_ti,phase_ti,AmplitudeOrder,PhaseOrder)
    C_psi_interp[:,Nt] = interpolate.griddata(rho,C_amp,rho_norm, method='linear',)  
    C_phi_interp[:,Nt] = interpolate.griddata(rho,C_phi,rho_norm, method='linear',)    
    

figsize = (10,2.5)

PlotData = C_psi_interp
plt.figure(figsize=figsize)
# plt.plot(X,GradPhi[0,:,:]+np.array(range(len(time)))*5)
cmax = (PlotData).max()
cmap = 'jet'
plt.pcolor(time,rho_norm/xi_0,PlotData,clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('Correlation function $C_{\\psi}$')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$r/ \\xi_{0}$')
plt.savefig(newpath+'/Corr_psi.png', transparent=True, bbox_inches = "tight", dpi=dpi)

PlotData = np.real(C_phi_interp)
plt.figure(figsize=figsize)
# plt.plot(X,GradPhi[0,:,:]+np.array(range(len(time)))*5)
cmax = (PlotData).max()
cmap = 'jet'
plt.pcolor(time,rho_norm/xi_0,PlotData,clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('Correlation function Re{$C_{\\theta_s}$}')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$r/ \\xi_{0}$')
plt.savefig(newpath+'/Corr_theta_re.png', transparent=True, bbox_inches = "tight", dpi=dpi)

PlotData = np.imag(C_phi_interp)
plt.figure(figsize=figsize)
# plt.plot(X,GradPhi[0,:,:]+np.array(range(len(time)))*5)
cmax = (PlotData).max()
cmap = 'jet'
plt.pcolor(time,rho_norm/xi_0,PlotData,clim=[-cmax,cmax],cmap=cmap)
plt.colorbar()
plt.title('Correlation function Im{$C_{\\theta_s}$}')
plt.xlabel('$t/ \\tau_{GL}$')
plt.ylabel('$r/ \\xi_{0}$')
plt.savefig(newpath+'/Corr_theta_im.png', transparent=True, bbox_inches = "tight", dpi=dpi)

np.savetxt(newpath+'/Corr_rho.txt', rho_norm)
np.savetxt(newpath+'/Corr_psi.txt', C_psi_interp.reshape(C_psi_interp.shape[0], -1))
np.savetxt(newpath+'/Corr_theta_re.txt', np.real(C_phi_interp).reshape(C_phi_interp.shape[0], -1))
np.savetxt(newpath+'/Corr_theta_im.txt', np.imag(C_phi_interp).reshape(C_phi_interp.shape[0], -1))

print('Correlation: Done.')

''' Done. '''
"""