# -*- coding: utf-8 -*-
"""M3_UConn_E_arg_I_arg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eko4f29jxpmfPyyTE0WHsAJluPe-Ihaf
"""

## Current cases:
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--E", type=float, help="E0i")
parser.add_argument("--I", type=float, help="current_amp")
args = parser.parse_args()

E0i = args.E
current_amp = args.I

print(f"E0i is {args.E}, and current is {args.I}")

import numpy as np

w_input_set = 2*np.pi / 40
solve_time = 500
t_on, t_off, time_evolute = [0, solve_time, True]
mesh_size = 4

"""# Simulation of Laguerre-Gaussian beam on superconductors
- Edit by TTYeh (20250415) <br>

### Load function
The following codes work for both Colab environment and tdgl environment (Installation: https://py-tdgl.readthedocs.io/en/latest/) <br>
This section is for loading the revised functions (originally from Logan's code).
"""

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_formats = {"retina", "png"}
Execute_GPU = True

import os
os.environ["OPENBLAS_NUM_THREADS"] = "1"
import matplotlib.pyplot as plt
import numpy as np

plt.rcParams["figure.figsize"] = (7.5, 2.5)

import tdgl
# from tdgl.geometry import box, circle
# from tdgl.visualization.animate import create_animation
tdgl.SolverOptions.gpu = Execute_GPU # !!! Turn on GPU calculation !!!
from IPython.display import HTML, display
import h5py

import logging
import os
import shutil
from contextlib import nullcontext
from logging import Logger
from typing import Any, Dict, Literal, Optional, Sequence, Tuple, Union

from matplotlib import animation
from matplotlib import pyplot as plt
from tqdm import tqdm

from tdgl.device.device import Device
from tdgl.solution.data import get_data_range
from tdgl.visualization.common import DEFAULT_QUANTITIES, PLOT_DEFAULTS, Quantity, auto_grid
from tdgl.visualization.io import get_plot_data, get_state_string

def delete_files_in_directory(directory_path):
   try:
     files = os.listdir(directory_path)
     for file in files:
       file_path = os.path.join(directory_path, file)
       if os.path.isfile(file_path):
         os.remove(file_path)
     print("All files deleted successfully.")
   except OSError:
     print("Error occurred while deleting files.")

def create_animation_withEMwave(
    input_file: Union[str, h5py.File],
    *,
    output_file: Optional[str] = None,
    quantities: Union[str, Sequence[str]] = DEFAULT_QUANTITIES,
    shading: Literal["flat", "gouraud"] = "gouraud",
    fps: int = 30,
    dpi: float = 100,
    max_cols: int = 6,
    min_frame: int = 0,
    max_frame: int = -1,
    autoscale: bool = False,
    dimensionless: bool = False,
    xlim: Optional[Tuple[float, float]] = None,
    ylim: Optional[Tuple[float, float]] = None,
    axis_labels: bool = False,
    axes_off: bool = False,
    title_off: bool = False,
    full_title: bool = True,
    logger: Optional[Logger] = None,
    figure_kwargs: Optional[Dict[str, Any]] = None,
    writer: Union[str, animation.MovieWriter, None] = None,
    quiver_scale = 10,
    quiver_mesh_n = 20,
    width_quiver = 0.01,
) -> animation.FuncAnimation:
    """Generates, and optionally saves, and animation of a TDGL simulation.

    Args:
        input_file: An open h5py file or a path to an H5 file containing
            the :class:`tdgl.Solution` you would like to animate.
        output_file: A path to which to save the animation,
            e.g., as a gif or mp4 video.
        quantities: The names of the quantities to animate.
        shading: Shading method, "flat" or "gouraud". See matplotlib.pyplot.tripcolor.
        fps: Frame rate in frames per second.
        dpi: Resolution in dots per inch.
        max_cols: The maxiumum number of columns in the subplot grid.
        min_frame: The first frame of the animation.
        max_frame: The last frame of the animation.
        autoscale: Autoscale colorbar limits at each frame.
        dimensionless: Use dimensionless units for axes
        xlim: x-axis limits
        ylim: y-axis limits
        axes_off: Turn off the axes for each subplot.
        title_off: Turn off the figure suptitle.
        full_title: Include the full "state" for each frame in the figure suptitle.
        figure_kwargs: Keyword arguments passed to ``plt.subplots()`` when creating
            the figure.
        writer: A :class:`matplotlib.animation.MovieWriter` instance to use when
            saving the animation.
        logger: A logger instance to use.

    Returns:
        The animation as a :class:`matplotlib.animation.FuncAnimation`.
    """
    writer = animation.FFMpegWriter()

    if isinstance(input_file, str):
        input_file = input_file
    if quantities is None:
        quantities = Quantity.get_keys()
    if isinstance(quantities, str):
        quantities = [quantities]
    quantities = [Quantity.from_key(name.upper()) for name in quantities]
    num_plots = len(quantities) +2 # Add two more subplots for E, Bz
    logger = logger or logging.getLogger()
    figure_kwargs = figure_kwargs or dict()
    figure_kwargs.setdefault("constrained_layout", True)
    default_figsize = (
        3.25 * min(max_cols, num_plots),
        2.5 * max(1, num_plots // max_cols),
    )
    figure_kwargs.setdefault("figsize", default_figsize)
    figure_kwargs.setdefault("sharex", True)
    figure_kwargs.setdefault("sharey", True)

    logger.info(f"Creating animation for {[obs.name for obs in quantities]!r}.")

    mpl_context = nullcontext() if output_file is None else plt.ioff()
    if isinstance(input_file, str):
        h5_context = h5py.File(input_file, "r")
    else:
        h5_context = nullcontext(input_file)

    with h5_context as h5file:
        with mpl_context:
            device = Device.from_hdf5(h5file["solution/device"])
            mesh = device.mesh
            if dimensionless:
                scale = 1
                units_str = "\\xi"
            else:
                scale = device.layer.coherence_length
                units_str = f"{device.ureg(device.length_units).units:~L}"
            x, y = scale * mesh.sites.T

            # Get the ranges for the frame
            _min_frame, _max_frame = get_data_range(h5file)
            min_frame = max(min_frame, _min_frame)
            if max_frame == -1:
                max_frame = _max_frame
            else:
                max_frame = min(max_frame, _max_frame)

            # Temp data to use in plots
            temp_value = np.ones(len(mesh.sites), dtype=float)
            temp_value[0] = 0
            temp_value[1] = 0.5

            fig, axes = auto_grid(num_plots, max_cols=max_cols, **figure_kwargs)
            collections = []
            quantities.append('E') # Add one more quantities
            quantities.append('Bz') # Add one more quantities
            X = np.linspace(-width/2,width/2,quiver_mesh_n)
            Y = np.linspace(-height/2,height/2,quiver_mesh_n)
            Xv, Yv = np.meshgrid(X, Y)
            ti = dict(input_file['data'][str(1)].attrs)['time']
            E_x, E_y = E_input_frame(Xv,Yv,ti,take_real=False)
            B_x, B_y, B_z = E2Bv(Xv,Yv,E0i*E_x,E0i*E_y,constant_Bz,c,w_input)
            Bzmax, Bzmin = [find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input), -find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input)]

            for quantity, ax in zip(quantities, axes.flat):
                ax: plt.Axes
                if quantity!='E' and quantity!='Bz':
                    opts = PLOT_DEFAULTS[quantity]
                    collection = ax.tripcolor(
                        x,
                        y,
                        temp_value,
                        triangles=mesh.elements,
                        shading=shading,
                        cmap=opts.cmap,
                        vmin=opts.vmin,
                        vmax=opts.vmax,
                    )
                    cbar = fig.colorbar(collection, ax=ax)
                    cbar.set_label(opts.clabel)
                    ax.set_aspect("equal")
                    ax.set_title(quantity.value)
                    ax.set_xlim(xlim)
                    ax.set_ylim(ylim)
                    if axes_off:
                        ax.axis("off")
                    if axis_labels:
                        ax.set_xlabel(f"$x$ [${units_str}$]")
                        ax.set_ylabel(f"$y$ [${units_str}$]")
                    collections.append(collection)

                if quantity=='E': # For new plot: "E"
                    collection = ax.quiver(
                        Xv,
                        Yv,
                        np.real(E_x),
                        np.real(E_y),
                        scale=quiver_scale,
                        scale_units='x',
                        width=width_quiver*abs(X[2]-X[1]),
                    )
                    ax.set_aspect("equal")
                    ax.set_title('$E$')
                    ax.set_xlim(xlim)
                    ax.set_ylim(ylim)
                    if axes_off:
                        ax.axis("off")
                    if axis_labels:
                        ax.set_xlabel(f"$x$ [${units_str}$]")
                        ax.set_ylabel(f"$y$ [${units_str}$]")
                    collections.append(collection)
                if quantity=='Bz': # For new plot: "Bz"
                    collection = ax.pcolormesh(
                        X,
                        Y,
                        np.real(B_z),
                        cmap="PRGn",
                        shading='gouraud',
                        vmin=Bzmin,
                        vmax=Bzmax,
                    )
                    cbar = plt.colorbar(collection)
                    cbar.set_label('$B_{z}$ ['+field_units+']')
                    ax.set_aspect("equal")
                    ax.set_title('$B_{z}$ ')
                    ax.set_xlim(xlim)
                    ax.set_ylim(ylim)
                    if axes_off:
                        ax.axis("off")
                    if axis_labels:
                        ax.set_xlabel(f"$x$ [${units_str}$]")
                        ax.set_ylabel(f"$y$ [${units_str}$]")
                    collections.append(collection)
            vmins = [+np.inf for _ in quantities]
            vmaxs = [-np.inf for _ in quantities]

            def update(frame):
                if not h5file:
                    return
                frame += min_frame
                state = get_state_string(h5file, frame, max_frame)
                if not full_title:
                    state = state.split(",")[0]
                if not title_off:
                    fig.suptitle(state)

                ti = dict(input_file['data'][str(frame)].attrs)['time']
                E_x, E_y = E_input_frame(Xv,Yv,ti,take_real=False)
                B_x, B_y, B_z = E2Bv(Xv,Yv,E0i*E_x,E0i*E_y,constant_Bz,c,w_input)

                for i, (quantity, collection) in enumerate(
                    zip(quantities, collections)
                ):
                    if quantity!='E' and quantity!='Bz':
                        opts = PLOT_DEFAULTS[quantity]
                        values, direction, _ = get_plot_data(h5file, mesh, quantity, frame)
                        mask = np.abs(values - np.mean(values)) <= 6 * np.std(values)
                        if opts.vmin is None:
                            if autoscale:
                                vmins[i] = np.min(values[mask])
                            else:
                                vmins[i] = min(vmins[i], np.min(values[mask]))
                        else:
                            vmins[i] = opts.vmin
                        if opts.vmax is None:
                            if autoscale:
                                vmaxs[i] = np.max(values[mask])
                            else:
                                vmaxs[i] = max(vmaxs[i], np.max(values[mask]))
                        else:
                            vmaxs[i] = opts.vmax
                        if opts.symmetric:
                            vmax = max(abs(vmins[i]), abs(vmaxs[i]))
                            vmaxs[i] = vmax
                            vmins[i] = -vmax
                        if shading == "flat":
                            # https://stackoverflow.com/questions/40492511/set-array-in-tripcolor-bug
                            values = values[mesh.elements].mean(axis=1)
                        collection.set_array(values)
                        collection.set_clim(vmins[i], vmaxs[i])
                    if quantity=='E':
                        collection.set_UVC(np.real(E_x),np.real(E_y))
                    if quantity=='Bz':
                        collection.set_array(np.real(B_z))
                        collection.set_clim(Bzmin, Bzmax)
                fig.canvas.draw()

            anim = animation.FuncAnimation(
                fig,
                update,
                frames=max_frame - min_frame,
                interval=1e3 / fps,
                blit=False,
            )

        if output_file is not None:
            output_file = os.path.join(os.getcwd(), output_file)
            if writer is None:
                kwargs = dict(fps=fps)
            else:
                kwargs = dict(writer=writer)
            fname = os.path.basename(output_file)
            with tqdm(
                total=len(range(min_frame, max_frame)),
                unit="frames",
                desc=f"Saving to {fname}",
            ) as pbar:
                anim.save(
                    output_file,
                    dpi=dpi,
                    progress_callback=lambda frame, total: pbar.update(1),
                    **kwargs,
                )

        return anim

def make_video_from_solution(
    solution,
    quantities=("order_parameter", "phase"),
    fps=20,
    figsize=(5, 4),
    output_file='None',
    dpi=100,
    quiver_scale=10,
    quiver_mesh_n=20,
    width_quiver=0.01,
    writer=None,
):
    """Generates an HTML5 video from a tdgl.Solution."""

    with tdgl.non_gui_backend():
        with h5py.File(solution.path, "r") as h5file:
            anim = create_animation_withEMwave(
                h5file,
                quantities=quantities,
                fps=fps,
                figure_kwargs=dict(figsize=figsize),
                axis_labels = True,
                output_file=output_file,
                dpi=dpi,
                quiver_scale=quiver_scale,
                quiver_mesh_n=quiver_mesh_n,
                width_quiver=width_quiver,
                writer=writer,
            )
            video = anim.to_html5_video()
        return HTML(video)

MAKE_ANIMATIONS = True
# MAKE_ANIMATIONS = False
""" Done."""

"""#### Light source: Laguerre-Gaussian Beam
New part for time-dependent guage vector potential, including...
1. $E$ and $A$ of Laguerre-Gaussian Beam
2. Relevant tools
<!-- - Ref: http://kirkmcd.princeton.edu/examples/axicon_big.pdf <by> -->
"""

### LG beam

from scipy.special import genlaguerre
import scipy.constants as cons
from tdgl.parameter import Parameter
import pint # https://pint.readthedocs.io/en/0.10.1/tutorial.html

def uniform_Bz_vector_potential(
    positions: np.ndarray,
    Bz: Union[float, str, pint.Quantity],
) -> np.ndarray:
    """Calculates the magnetic vector potential [Ax, Ay, Az] at ``positions``
    due uniform magnetic field along the z-axis with strength ``Bz``.

    Args:
        positions: Shape (n, 3) array of (x, y, z) positions in meters at which to
            evaluate the vector potential.
        Bz: The strength of the uniform field, as a pint-parseable string,
            a pint.Quantity, or a float with units of Tesla.

    Returns:
        Shape (n, 3) array of the vector potential [Ax, Ay, Az] at ``positions``
        in units of Tesla * meter.
    """
    # assert isinstance(Bz, (float, str, pint.Quantity)), type(Bz)
    positions = np.atleast_2d(positions)
    # assert positions.shape[1] == 3, positions.shape
    # if not isinstance(positions, pint.Quantity):
    #     positions = positions * ureg("meter")
    # if isinstance(Bz, str):
    #     Bz = ureg(Bz)
    # if isinstance(Bz, float):
    #     Bz = Bz * ureg("tesla")
    xs = positions[:, 0]
    ys = positions[:, 1]
    dx = np.ptp(xs)
    dy = np.ptp(ys)
    xs = xs - (xs.min() + dx / 2)
    ys = ys - (ys.min() + dy / 2)
    Ax = -Bz * ys / 2
    Ay = Bz * xs / 2
    A = np.stack([Ax, Ay, np.zeros_like(Ax)], axis=1)
    return A

def constant_field_vector_potential(
    x,
    y,
    z,
    *,
    Bz: float,
    field_units: str = "mT",
    length_units: str = "um",
):
    if z.ndim == 0:
        z = z * np.ones_like(x)
    positions = np.array([x.squeeze(), y.squeeze(), z.squeeze()]).T
    # Bz = Bz * ureg(field_units)
    A = uniform_Bz_vector_potential(positions, Bz)
    return A

def findval(X,x_value):
    return np.argmin(abs(X-x_value))

def Cpl(p,l):
  if abs(p)==0: p=1
  factorial_p = 1
  factorial_pl = 1
  for i in range(abs(p)): factorial_p = factorial_p*(i+1)
  for i in range(abs(p)+abs(l)): factorial_pl = factorial_pl*(i+1)
  return np.sqrt(2*factorial_p/np.pi/factorial_pl)

### ------------------------------------------------------------------------------------------ ###

### A of LG beam (equip the functions of "Step structured Bz" and "constant uniform Bz")

def A_LG_t(x, y, z, *, t,
                   w: float = 1.0,
                   E0: float = 1.0,
                   w0: float = 1.0,
                   xc_Gauss: float = 0.0,
                   yc_Gauss: float = 0.0,
                   z0: float = 0.0,
                   n: float = 1.0,
                   phi0_t: float = 0,
                   phi0_xy: float = 0,
                   tau: float = 1.0,
                   p: float = 0.0,
                   l: float = 0.0,
                   s: float = 0.0,
                   c: float = 1.0,
                   t_on: float = 0.0,
                   t_off: float = 1.0,
                   Bz: float = 0,
                   polarization_modulation: bool = False,
                   polarization: str = 'none',
                   angular_freq_units: str = "THz",
                   length_units: str = "um",
                   field_units: str = "mT",
                   E_field_units: str = "newton / coulomb",
                   time_units: str = "ps",
                   take_complex=False,
                   time_evolute: bool = True,

):
    """ Vector potential of Laguerre-Gaussian beam of p-th degree of mode and l-th order of mode
    From E to A, A = -iE/w
    """
    X = (x-xc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of x-axis [um]
    Y = (y-yc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of y-axis [um]
    Z = (z-z0) * 1 # ureg(length_units)).to("m").magnitude   # mesh of y-axis [um]
    w0 = w0 * 1 # ureg(length_units) .to("m").magnitude   # Beam waist (suppose w0_x =w0_y) [um]
    k = w/c   # Wavenumber
    ti = np.copy(t)#(t * ureg(time_units)).to("s").magnitude   # Input time
    # E0 = (E0 * ureg(E_field_units)).to("newton / coulomb").magnitude   # Electrical field |E0|
    zR = n*k*w0**2/2   # Rayleigh length, n: refractive index
    wz = w0 * np.sqrt(1+(Z/zR)**2)   # Spot radius
    zeta = Z/zR

    r = np.sqrt(X**2+Y**2)   # Radius
    phi = np.angle(X+1j*Y)   # Azimuthal angle
    if polarization.lower()=='x' or polarization.lower()=='linear x': s, phi0_xy = [0.0,0.0]
    if polarization.lower()=='y' or polarization.lower()=='linear y': s, phi0_xy = [0.0,np.pi/2]
    if polarization.lower()=='lc' or polarization.lower()=='left circular': s, phi0_xy = [1,np.pi/4]
    if polarization.lower()=='rc' or polarization.lower()=='right circular': s, phi0_xy = [-1,np.pi/4]
    phi_t = np.copy(phi0_t) # !!!!!! ONLY CONSTANT PHASE REMAINS !!!!!!
    if time_evolute: phi_t = phi_t + w*ti
    phiGouy = (2*p+np.abs(l)+1)*np.arctan(Z/zR) # Gouy phase
    u = E0 * 1 * (np.sqrt(2)*r/wz)**l * genlaguerre(p,l)(2*r**2/wz**2) * w0/wz * np.exp(-1j*phiGouy +1j*(l*phi +k*z +k*r**2/2/(z-1j*zR)))

    if t>t_off or t<t_on: t_step = 0
    else: t_step = 1

    pol_m_x, pol_m_y = [np.cos(phi0_xy),np.sin(phi0_xy)]
    if polarization_modulation: pol_m_x, pol_m_y = (np.abs([np.cos(l*phi+phi0_xy), np.sin(l*phi+phi0_xy)]))
    Ex = u * np.exp(-1j*(phi_t)) * pol_m_x * t_step
    Ey = u * np.exp(-1j*(phi_t+s*np.pi/2)) * pol_m_y * t_step

    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Az = np.zeros_like(Ax)
    Ax[np.isnan(Ax)] = 0
    Ax[np.isinf(Ax)] = 0
    Ay[np.isnan(Ay)] = 0
    Ay[np.isinf(Ay)] = 0
    A_constBz = constant_field_vector_potential(x, y, z, Bz=Bz, field_units=field_units, length_units=length_units)
    A = np.stack([np.real(Ax), np.real(Ay), np.real(Az)], axis=1) + A_constBz
    if take_complex: A = np.stack([(Ax), (Ay), (Az)], axis=1) + A_constBz
    # A = np.array([np.real(Ax), np.real(Ay), np.real(Az)]).T
    return A#.to(f"{field_units} * {length_units}").magnitude

# callable(A_LG_t_xy)

def A_LG(*,
        w: float = 1.0,
        E0: float = 1.0,
        w0: float = 1.0,
        xc_Gauss: float = 0.0,
        yc_Gauss: float = 0.0,
        z0: float = 0.0,
        n: float = 1.0,
        phi0_t: float = 0,
        phi0_xy: float = 0,
        tau: float = 1.0,
        c: float = 1.0,
        p: float = 0.0,
        l: float = 0.0,
        s: float = 0.0,
        t_on: float = 0.0,
        t_off: float = 1.0,
        Bz: float = 0,
        polarization_modulation: bool = False,
        polarization: str = 'none',
        angular_freq_units: str = "THz",
        length_units: str = "um",
        E_field_units: str = "newton / coulomb",
        field_units: str = "mT",
        time_units: str = "ps",
        time_evolute: bool = True,
        time_dependent=True,
)-> Parameter:
    """Vector potential of Laguerre-Gaussian beam  LG(p)(l)
    # for linear polarization, LG00, phi0_xy could be any number and s=0
    # for Circular polarization, LG00, phi0_xy=pi/4 and s=+-1
    # for linear polarization, LG01, phi0_xy could be any number and s=0
    # for Circular polarization, LG01, phi0_xy=pi/4 and s=+-1
    # for Radial polarization, LG01, s=+1, phi0_xy=0, polarization_modulation = True
    # for Azimuthal polarization, LG01, s=+1, phi0_xy=np.pi/2, polarization_modulation = True

    Equip the function "Step structured Bz" and "constant uniform Bz"
    # Step structured Bz:
        # Step time: t_on, t_off, time_evolute = [t_on, t_off, False]
        # Continuous case: t_on, t_off, time_evolute = [0, solve_time, True]
    # constant Bz:
        # Bz = Bz

    Note of useful relation: f=w/2p, c=fL, k=2p/L, k=w/c, 1/w=1/kc=L/2pc

    Args:
        w: angular frequency ( w = 2 pi f ) ,
        k_dir: prapagation direction
        E0: amplitude of electrical field
        phi0_t: initial phase of time
        phi0_xy: initial angle of xy plane azimuthal angle
        tau: Unit time (SC dissipation time)
        p: Degree of mode
        l: Order of mode, or orbital angular momentum of LG beam
        s: spin angular momentum of LG beam
    Returns:
        A :class:`tdgl.Parameter` that produces a linear ramp.
    """
    return Parameter(
        A_LG_t,
        w=w,
        w0=w0,
        E0=E0i,
        phi0_t=phi0_t,
        phi0_xy=phi0_xy,
        xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
        p=p, l=l, s=s, c=c, Bz=Bz, z0=z0, n=n,
        tau=tau, t_on=t_on, t_off=t_off,
        polarization=polarization,
        polarization_modulation=polarization_modulation,
        angular_freq_units=angular_freq_units,
        length_units=length_units,
        E_field_units=E_field_units,
        field_units=field_units,
        time_units=time_units,
        time_evolute=time_evolute,
        time_dependent=True,
    )


### ------------------------------------------------------------------------------------------ ###

### A of LG beam on GPU (cupy)

# import cupy as cp

# def uniform_Bz_vector_potential_cupy(
#     positions: np.ndarray,
#     Bz: Union[float, str, pint.Quantity],
# ) -> cp.ndarray:
#     """Calculates the magnetic vector potential [Ax, Ay, Az] at ``positions``
#     due uniform magnetic field along the z-axis with strength ``Bz``.

#     Args:
#         positions: Shape (n, 3) array of (x, y, z) positions in meters at which to
#             evaluate the vector potential.
#         Bz: The strength of the uniform field, as a pint-parseable string,
#             a pint.Quantity, or a float with units of Tesla.

#     Returns:
#         Shape (n, 3) array of the vector potential [Ax, Ay, Az] at ``positions``
#         in units of Tesla * meter.
#     """
#     # assert isinstance(Bz, (float, str, pint.Quantity)), type(Bz)
#     positions = cp.atleast_2d(positions)
#     # assert positions.shape[1] == 3, positions.shape
#     # if not isinstance(positions, pint.Quantity):
#     #     positions = positions * ureg("meter")
#     # if isinstance(Bz, str):
#     #     Bz = ureg(Bz)
#     # if isinstance(Bz, float):
#     #     Bz = Bz * ureg("tesla")
#     xs = cp.array(positions[:, 0])
#     ys = cp.array(positions[:, 1])
#     dx = cp.ptp(xs)
#     dy = cp.ptp(ys)
#     xs = xs - (xs.min() + dx / 2)
#     ys = ys - (ys.min() + dy / 2)
#     Ax = -Bz * ys / 2
#     Ay = Bz * xs / 2
#     A = cp.stack([Ax, Ay, np.zeros_like(Ax)], axis=1)
#     return A

# def constant_field_vector_potential_cupy(
#     x,
#     y,
#     z,
#     *,
#     Bz: float,
#     field_units: str = "mT",
#     length_units: str = "um",
# ):
#     if z.ndim == 0:
#         z = z * cp.ones_like(x)
#     positions = cp.array([x.squeeze(), y.squeeze(), z.squeeze()]).T
#     # Bz = Bz * ureg(field_units)
#     A = uniform_Bz_vector_potential_cupy(positions, Bz)
#     return A

def A_LG_t_cupy(x, y, z, *, t,
                   w: float = 1.0,
                   E0: float = 1.0,
                   w0: float = 1.0,
                   xc_Gauss: float = 0.0,
                   yc_Gauss: float = 0.0,
                   z0: float = 0.0,
                   n: float = 1.0,
                   phi0_t: float = 0,
                   phi0_xy: float = 0,
                   tau: float = 1.0,
                   p: float = 0.0,
                   l: float = 0.0,
                   s: float = 0.0,
                   c: float = 1.0,
                   t_on: float = 0.0,
                   t_off: float = 1.0,
                   Bz: float = 0,
                   polarization_modulation: bool = False,
                   polarization: str = 'none',
                   angular_freq_units: str = "THz",
                   length_units: str = "um",
                   field_units: str = "mT",
                   E_field_units: str = "newton / coulomb",
                   time_units: str = "ps",
                   take_complex=False,
                   time_evolute: bool = True,

):
    """ Vector potential of Laguerre-Gaussian beam of p-th degree of mode and l-th order of mode
    From E to A, A = -iE/w
    """
    X = cp.array(x-xc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of x-axis [um]
    Y = cp.array(y-yc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of y-axis [um]
    Z = cp.array(z-z0) * 1 # ureg(length_units)).to("m").magnitude   # mesh of y-axis [um]
    w0 = w0 * 1 # ureg(length_units) .to("m").magnitude   # Beam waist (suppose w0_x =w0_y) [um]
    k = w/c   # Wavenumber
    ti = (t)#(t * ureg(time_units)).to("s").magnitude   # Input time
    # E0 = (E0 * ureg(E_field_units)).to("newton / coulomb").magnitude   # Electrical field |E0|
    # print(ti)
    zR = cp.array(n*k*w0**2/2)   # Rayleigh length, n: refractive index
    # print(zR)
    # print(w0)
    wz = cp.array(w0 * cp.sqrt(1+(Z/zR)**2))   # Spot radius
    zeta = cp.array(Z/zR)

    r = cp.sqrt(X**2+Y**2)   # Radius
    phi = cp.angle(X+1j*Y)   # Azimuthal angle
    if polarization.lower()=='x' or polarization.lower()=='linear x': s, phi0_xy = [0.0,0.0]
    if polarization.lower()=='y' or polarization.lower()=='linear y': s, phi0_xy = [0.0,np.pi/2]
    if polarization.lower()=='lc' or polarization.lower()=='left circular': s, phi0_xy = [1,np.pi/4]
    if polarization.lower()=='rc' or polarization.lower()=='right circular': s, phi0_xy = [-1,np.pi/4]
    phi_t = (phi0_t) # !!!!!! ONLY CONSTANT PHASE REMAINS !!!!!!
    if time_evolute: phi_t = phi_t + w*ti
    phiGouy = cp.array((2*p+cp.abs(l)+1)*cp.arctan(Z/zR)) # Gouy phase
    # genlaguerre: https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html
    # u = E0 * Cpl(p,l)/w0 * (cp.sqrt(2)*r/(wz))**l * cp.array(genlaguerre(p,l)(2*np.array(r**2)/np.array(wz**2))) * w0/wz * cp.exp( -1j*phiGouy +1j*(l*phi +k*Z +k*r**2/2/(Z-1j*zR)))
    u = E0 * 1 * (cp.sqrt(2)*r/(wz))**l * 1 * w0/wz * cp.exp(-1j*phiGouy +1j*(l*phi +k*Z +k*r**2/2/(Z-1j*zR)))
    if t>t_off or t<t_on: t_step = 0
    else: t_step = 1

    pol_m_x, pol_m_y = [cp.cos(phi0_xy),cp.sin(phi0_xy)]
    if polarization_modulation: pol_m_x, pol_m_y = (cp.abs([cp.cos(l*phi+phi0_xy), cp.sin(l*phi+phi0_xy)]))
    Ex = u * cp.exp(-1j*(phi_t)) * pol_m_x * t_step
    Ey = u * cp.exp(-1j*(phi_t+s*cp.pi/2)) * pol_m_y * t_step

    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Az = cp.zeros_like(Ax)
    Ax[np.isnan(Ax)] = 0
    Ax[np.isinf(Ax)] = 0
    Ay[np.isnan(Ay)] = 0
    Ay[np.isinf(Ay)] = 0
    A_constBz = 0#constant_field_vector_potential_cupy(x, y, z, Bz=Bz, field_units=field_units, length_units=length_units)
    A = cp.stack([cp.real(Ax), cp.real(Ay), cp.real(Az)], axis=1) + A_constBz
    if take_complex: A = cp.stack([(Ax), (Ay), (Az)], axis=1) + A_constBz
    # A = np.array([np.real(Ax), np.real(Ay), np.real(Az)]).T
    return cp.asnumpy(A)#.to(f"{field_units} * {length_units}").magnitude

def A_LG_cupy(*,
        w: float = 1.0,
        E0: float = 1.0,
        w0: float = 1.0,
        xc_Gauss: float = 0.0,
        yc_Gauss: float = 0.0,
        z0: float = 0.0,
        n: float = 1.0,
        phi0_t: float = 0,
        phi0_xy: float = 0,
        tau: float = 1.0,
        c: float = 1.0,
        p: float = 0.0,
        l: float = 0.0,
        s: float = 0.0,
        t_on: float = 0.0,
        t_off: float = 1.0,
        Bz: float = 0,
        polarization_modulation: bool = False,
        polarization: str = 'none',
        angular_freq_units: str = "THz",
        length_units: str = "um",
        E_field_units: str = "newton / coulomb",
        field_units: str = "mT",
        time_units: str = "ps",
        time_evolute: bool = True,
        time_dependent=True,
)-> Parameter:
    """Vector potential of Laguerre-Gaussian beam  LG(p)(l)
    # for linear polarization, LG00, phi0_xy could be any number and s=0
    # for Circular polarization, LG00, phi0_xy=pi/4 and s=+-1
    # for linear polarization, LG01, phi0_xy could be any number and s=0
    # for Circular polarization, LG01, phi0_xy=pi/4 and s=+-1
    # for Radial polarization, LG01, s=+1, phi0_xy=0, polarization_modulation = True
    # for Azimuthal polarization, LG01, s=+1, phi0_xy=np.pi/2, polarization_modulation = True

    Equip the function "Step structured Bz" and "constant uniform Bz"
    # Step structured Bz:
        # Step time: t_on, t_off, time_evolute = [t_on, t_off, False]
        # Continuous case: t_on, t_off, time_evolute = [0, solve_time, True]
    # constant Bz:
        # Bz = Bz

    Note of useful relation: f=w/2p, c=fL, k=2p/L, k=w/c, 1/w=1/kc=L/2pc

    Args:
        w: angular frequency ( w = 2 pi f ) ,
        k_dir: prapagation direction
        E0: amplitude of electrical field
        phi0_t: initial phase of time
        phi0_xy: initial angle of xy plane azimuthal angle
        tau: Unit time (SC dissipation time)
        p: Degree of mode
        l: Order of mode, or orbital angular momentum of LG beam
        s: spin angular momentum of LG beam
    Returns:
        A :class:`tdgl.Parameter` that produces a linear ramp.
    """
    return Parameter(
        A_LG_t_cupy,
        w=w,
        w0=w0,
        E0=E0i,
        phi0_t=phi0_t,
        phi0_xy=phi0_xy,
        xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
        p=p, l=l, s=s, c=c, Bz=Bz, z0=z0, n=n,
        tau=tau, t_on=t_on, t_off=t_off,
        polarization=polarization,
        polarization_modulation=polarization_modulation,
        angular_freq_units=angular_freq_units,
        length_units=length_units,
        E_field_units=E_field_units,
        field_units=field_units,
        time_units=time_units,
        time_evolute=time_evolute,
        time_dependent=True,
    )


### ------------------------------------------------------------------------------------------ ###

### Bz component

# B = curl(A) = (dyAz - dzAy) ex + (dzAx - dxAz) ey + (dxAy - dyAx) ez
def A2B(x, y, z, A):

    ''' Calculate magnetic field B from vector potential A
    return B
    '''
    B.x = np.diff(A[:,2])/np.diff(y) - np.diff(A[:,1])/np.diff(z)
    B.y = np.diff(A[:,0])/np.diff(z) - np.diff(A[:,2])/np.diff(x)
    B.z = np.diff(A[:,1])/np.diff(x) - np.diff(A[:,0])/np.diff(y)
    return B

def E_LG_t(x, y, z, *, t,
                   w: float = 1.0,
                   E0: float = 1.0,
                   w0: float = 1.0,
                   xc_Gauss: float = 0.0,
                   yc_Gauss: float = 0.0,
                   z0: float = 0.0,
                   n: float = 1.0,
                   phi0_t: float = 0,
                   phi0_xy: float = 0,
                   tau: float = 1.0,
                   p: float = 0.0,
                   l: float = 0.0,
                   s: float = 0.0,
                   c: float = 1.0,
                   t_on: float = 0.0,
                   t_off: float = 1.0,
                   Bz: float = 0,
                   polarization_modulation: bool = False,
                   polarization: str = 'none',
                   angular_freq_units: str = "THz",
                   length_units: str = "um",
                   field_units: str = "mT",
                   E_field_units: str = "newton / coulomb",
                   time_units: str = "ps",
                   time_evolute: bool = True,

):
    """ Electric field x, y of Laguerre-Gaussian beam of p-th degree of mode and l-th order of mode
    From E to A, A = -iE/w
    """
    X = (x-xc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of x-axis [um]
    Y = (y-yc_Gauss) * 1 # ureg(length_units).to("m").magnitude   # mesh of y-axis [um]
    Z = (z-z0) * 1 # ureg(length_units)).to("m").magnitude   # mesh of y-axis [um]
    w0 = w0 * 1 # ureg(length_units) .to("m").magnitude   # Beam waist (suppose w0_x =w0_y) [um]
    k = w/c   # Wavenumber
    ti = np.copy(t)#(t * ureg(time_units)).to("s").magnitude   # Input time
    # E0 = (E0 * ureg(E_field_units)).to("newton / coulomb").magnitude   # Electrical field |E0|
    zR = (n*k*w0**2/2)   # Rayleigh length, n: refractive index
    wz = w0 * np.sqrt(1+(Z/zR)**2)   # Spot radius
    zeta = Z/zR

    r = np.sqrt(X**2+Y**2)   # Radius
    phi = np.angle(X+1j*Y)   # Azimuthal angle
    if polarization.lower()=='x' or polarization.lower()=='linear x': s, phi0_xy = [0.0,0.0]
    if polarization.lower()=='y' or polarization.lower()=='linear y': s, phi0_xy = [0.0,np.pi/2]
    if polarization.lower()=='lc' or polarization.lower()=='left circular': s, phi0_xy = [1,np.pi/4]
    if polarization.lower()=='rc' or polarization.lower()=='right circular': s, phi0_xy = [-1,np.pi/4]
    phi_t = np.copy(phi0_t) # !!!!!! ONLY CONSTANT PHASE REMAINS !!!!!!
    if time_evolute: phi_t = phi_t + w*ti
    phiGouy = (2*p+np.abs(l)+1)*np.arctan(Z/zR) # Gouy phase
    u = E0 * 1 * (np.sqrt(2)*r/wz)**l * genlaguerre(p,l)(2*r**2/wz**2) * w0/wz * np.exp(-1j*phiGouy +1j*(l*phi +k*z +k*r**2/2/(z-1j*zR)))

    if t>t_off or t<t_on: t_step = 0
    else: t_step = 1

    pol_m_x, pol_m_y = [np.cos(phi0_xy),np.sin(phi0_xy)]
    if polarization_modulation: pol_m_x, pol_m_y = (np.abs([np.cos(l*phi+phi0_xy), np.sin(l*phi+phi0_xy)]))
    Ex = u * np.exp(-1j*(phi_t)) * pol_m_x * t_step
    Ey = u * np.exp(-1j*(phi_t+s*np.pi/2)) * pol_m_y * t_step
    Ez = np.zeros_like(Ex)
    return Ex, Ey, Ez

def E2B(x,y,Ex,Ey,Bz_constant,c,w):
    By = Ex/c
    Bx = -Ey/c
    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Bz_A = np.zeros_like(By)
    Bz_A[1:] = np.diff(Ay)/np.diff(x) - np.diff(Ax)/np.diff(y)
    Bz = Bz_A + Bz_constant
    # B = np.stack([np.real(Bx), np.real(By), np.real(Bz)], axis=1)
    return Bx, By, Bz #.to(f"{field_units}").magnitude

def E2Bv(xv,yv,Ex,Ey,Bz_constant,c,w):
    By = Ex/c
    Bx = -Ey/c
    Ax = -1j/w*Ex
    Ay = -1j/w*Ey
    Bz_A = np.zeros_like(By)
    dAydx = np.diff(np.real(Ay),axis=1)/np.diff(xv,axis=1)
    dAxdy = np.diff(np.real(Ax),axis=0)/np.diff(yv,axis=0)
    Bz_A[1:,1:] =  dAydx[1:,:] - dAxdy[:,1:]
    Bz = Bz_A + np.ones_like(Bz_A)*Bz_constant
    # B = np.stack([np.real(Bx), np.real(By), np.real(Bz)], axis=1)
    return Bx, By, Bz #.to(f"{field_units}").magnitude

def find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w):
    Ex, Ey = E_input_frame(Xv,Yv,0,take_real=False)
    Bx, By, Bz1 = E2Bv(Xv,Yv,E0i*Ex,E0i*Ey,0,c,w)
    Ex, Ey = E_input_frame(Xv,Yv,2*np.pi/4/w,take_real=False)
    Bx, By, Bz2 = E2Bv(Xv,Yv,E0i*Ex,E0i*Ey,0,c,w)
    Ex, Ey = E_input_frame(Xv,Yv,2*np.pi/2/w,take_real=False)
    Bx, By, Bz3 = E2Bv(Xv,Yv,E0i*Ex,E0i*Ey,0,c,w)
    return max([abs(np.real(Bz1)).max(), abs(np.real(Bz2)).max(), abs(np.real(Bz3)).max()]) + constant_Bz


### ------------------------------------------------------------------------------------------ ###

### Other useful functions

def light_state_contral(keyword_of_state):

    ''' Select the parameters for optical states
    options: 'lg00_l_x','lg00_l_y','lg00_c_l','lg00_c_r','lg01_l_x','lg01_l_y','lg01_c_c','lg01_c_r','lg01_c_a'
    return p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head
    '''

    p = int(keyword_of_state[2])
    l = int(keyword_of_state[3])
    if keyword_of_state[-1].lower()=='x': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [0,0,0, False,'_linear_x']
    if keyword_of_state[-1].lower()=='y': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [0,0,np.pi/2, False,'_linear_y']
    if keyword_of_state[-1].lower()=='l': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [1,0,np.pi/4, False,'_circular_l']
    if keyword_of_state[-1].lower()=='r': s, phi0_t, phi0_xy, polarization_modulation, output_file_head_suffix = [-1,0,np.pi/4, False,'_circular_r']
    output_file_head = 'LG'+str(p)+str(l)+output_file_head_suffix

## Linear polatization, Gauss:  for linear polarization, phi0_xy could be any number and s=0
    if keyword_of_state.lower()=='lg00_l_x': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,0,0,0, False,'LG00_linear_x']
    if keyword_of_state.lower()=='lg00_l_y': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,0,0,np.pi/2, False,'LG00_linear_y']
 ## Circular polatization, Gauss: for Circular polarization, phi0_xy=pi/4 and s=+-1
    if keyword_of_state.lower()=='lg00_c_l': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,1,0,np.pi/4, False,'LG00_circular_l']
    if keyword_of_state.lower()=='lg00_c_r': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,0,-1,0,np.pi/4, False,'LG00_circular_r']
## Linear polatization, LG01: for linear polarization, phi0_xy could be any number and s=0
    if keyword_of_state.lower()=='lg01_l_x': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,0,0,0, False,'LG01_linear_x']
    if keyword_of_state.lower()=='lg01_l_y': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,0,0,np.pi/2, False,'LG01_linear_y']
## Circular polatization, LG01 (Radial + Azimuthal): for Circular polarization, phi0_xy=pi/4 and s=+-1
    if keyword_of_state.lower()=='lg01_c_c': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,np.pi/4, False,'LG01_circular_c']
    if keyword_of_state.lower()=='lg01_c_l': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,np.pi/4, False,'LG01_circular_l']
    if keyword_of_state.lower()=='lg01_c_r': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,-1,0,np.pi/4, False,'LG01_circular_r']
## Radial polatization, LG01: for Radial polarization, s=+1, phi0_xy=0, polarization_modulation = True
    if keyword_of_state.lower()=='lg01_c_r': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,0, True,'LG01_circular_r']
## Azimuthal polatization, LG01: for Azimuthal polarization, s=+1, phi0_xy=np.pi/2, polarization_modulation = True
    if keyword_of_state.lower()=='lg01_c_a': p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = [0,1,1,0,np.pi/2, True,'LG01_circular_a']

    return p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head

def plot_polarization(X,Y,E_x,E_y,*,E0i:float=1.0,title:str='',figsize:(3, 3),scale:float=12,dpi:float=100):
    fig = plt.figure(figsize=figsize,constrained_layout=True,dpi=dpi)
    plt.title(title)
    plt.quiver(X,Y,E_x/E0i,E_y/E0i,scale=12, scale_units='x',width=0.1*abs(X[2]-X[1]))
    plt.xlabel('x ($\mu$m)')
    plt.ylabel('y ($\mu$m)')

def plot_EM(X,Y,E_x,E_y,B_z,*,E0i:float=1.0,title:str='',figsize:(6, 3),scale:float=12,dpi:float=100,take_Bz_range:bool=False,width_quiver:float=0.01):
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize,dpi=dpi) #constrained_layout=True,
    fig.suptitle(title)
    ax1.quiver(X,Y,E_x/E0i,E_y/E0i,scale=quiver_scale, scale_units='x',width=width_quiver*abs(X[2]-X[1]))
    ax1.set_xlabel('x ($\mu$m)')
    ax1.set_ylabel('y ($\mu$m)')
    # ax1.text(min(X)*.95, max(Y)*.85, '$|E_{0}|$: '+str(E0i), horizontalalignment='left', fontsize='large')
    ax1.set_aspect("equal")
    if take_Bz_range: Bzmax, Bzmin = [find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input), -find_max_Bz(Xv,Yv,E0i,constant_Bz,c,w_input)]
    else: Bzmax, Bzmin = [B_z.max(), B_z.min()]
    contour_Bz = ax2.contourf(Xv, Yv, B_z, levels=50, linewidths=0.0, cmap="PRGn",vmin=Bzmin,vmax=Bzmax)
    cbar = plt.colorbar(contour_Bz)
    cbar.set_label('$B_{z}$ ['+field_units+']')
    ax2.set_xlabel('x ($\mu$m)')
    ax2.set_ylabel('y ($\mu$m)')
    # ax2.text(min(X)*.95, max(Y)*.85, '$|B_{z,0}|$: '+str(E0i), horizontalalignment='left', fontsize='large')
    ax2.set_aspect("equal")

def v_grid_generation(p1,p2,p3,p4,quiver_mesh_n): # (-width/2,width/2,-height/2,height/2,quiver_mesh_n)
    X = np.linspace(p1,p2,quiver_mesh_n)
    Y = np.linspace(p3,p4,quiver_mesh_n)
    Xv, Yv = np.meshgrid(X, Y)
    Zv = np.zeros_like(Xv)
    return X, Y, Xv, Yv, Zv

### Unit transfer and check

from datetime import datetime
import pytz

def Unit_check_save(E0i,w0,w,light_source_state,length_units,E_field_units,angular_freq_units,subtitle,solve_time,screenSet,folder_name,Bz_max):

    ## Unit transfer
    w0 = (w0 * ureg(length_units)).to(length_units).magnitude   # Beam waist (suppose w0_x =w0_y)
    tau = tau_0.to(time_units).magnitude   # Unit time
    c = (cons.speed_of_light * ureg('m/s').to(length_units+'/'+time_units) * tau).magnitude   # speed of light (3e8 * tau  m/s)
    p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = light_state_contral(light_source_state)
    B0 = (1/c) * ureg(field_units)
    A0 = (1/w) * ureg(f"{field_units} * {length_units}")
    E0 = B0 * speed_of_light

    ## Save to data
    file_name = folder_name+'/'+subtitle+output_file_head+"_rec.txt"
    f = open(file_name, "w")
    f.write("File name "+file_name+"\n")
    f.write("Time now (at Stockholm):"+str(datetime.now(pytz.timezone('Europe/Stockholm')))+"\n")
    f.write(":: Parameter record ::\n")
    f.write("[1] Length scale of sample\n")
    f.write("Coherent length (xi): "+str(xi_coherent)+"\n")
    f.write("London penetration depth (london_lambda): "+str(lambdaL)+"\n")
    f.write("Thickness (thickness): "+str(d_thickness)+"\n")
    f.write("Screen length (lambdaL**2/thickness): "+str(screen_length)+"\n")
    f.write("Ratio of length kapa (lambdaL/xi): "+str(lambdaL/xi_coherent)+"\n")
    f.write("[2] Condictivity and  of sample\n")
    f.write("Resistivity (resistivity): "+str(resistivity)+"\n")
    f.write("Condictivity (1/resistivity): "+str(condictivity)+"\n")
    f.write("[3] Time scale of sample\n")
    f.write("Characteristic timescale (tau_0): "+str(tau_0.to(time_units))+"\n") # characteristic timescale for this TDGL model
    f.write("Characteristic rate (1/tau_0): "+str((1/tau_0).to('THz'))+"\n")
    f.write("Speed of light (unit of tau_0): "+str(revised_speed_of_light)+"\n")
    f.write("c input into A_LG (c): "+str(c)+"\n")
    f.write("tau input into A_LG (tau_0.to(s)): "+str(tau)+"\n")
    f.write("k calculated inside A_LG (w/c): "+str(w/c)+"\n")
    f.write("[4] Gap of sample\n")
    f.write("Given inelastic coupling rate (rate_eph): "+str(E_eph)+"\n")
    f.write("Given SC gap energy (gap_0): "+str(E_gap_0)+"\n")
    f.write("Frequency of SC gap (gap_0*0.242): "+str(F_gap_0)+"\n")
    f.write("Strength of inelastic scattering (gamma=2/rate_eph*gap_0): "+str(gamma)+"\n")
    f.write("[5] Parameters of light source\n")
    f.write("Beam size (2w0): "+str(2*w0 * ureg(length_units))+"\n")
    wavelength_of_light = (cons.speed_of_light * ureg('m/s') / ((w/2/np.pi/tau_0).to('THz'))).to(length_units)
    f.write("Wavelength: "+str(wavelength_of_light)+"\n")
    f.write("Beam size / wavelength: "+str((2*w0 * ureg(length_units)) / wavelength_of_light)+"\n")
    if (2*w0 * ureg(length_units) / wavelength_of_light).magnitude<1: print('[Warning] !!! ---Beam size is smaller than wavelength.--- !!!')
    if time_evolute: f.write("Angular frequency of light (w, unit of tau): "+str(w)+"\n")
    if time_evolute: f.write("Angular frequency of light (w, real value): "+str((w/tau_0).to(angular_freq_units))+"\n")
    if time_evolute: f.write("Frequency of light (w/2pi, unit of tau): "+str(w/2/np.pi)+"\n")
    if time_evolute: f.write("Frequency of light (w/2pi, real value): "+str((w/2/np.pi/tau_0).to(angular_freq_units))+"\n")
    if time_evolute!=True: f.write("Time evolution setting is False (no frequency is used).")
    f.write("EM field switch-on at (unit of tau): "+str(t_on)+"\n")
    f.write("EM field switch-off at (unit of tau): "+str(t_off)+"\n")
    f.write("|E0| of light (case of E0=1): "+str(E0.to(E_field_units))+"\n")
    f.write("In-plane |B0| of light (|E0|/c): "+str(B0)+"\n")
    f.write("In-plane |A0| of light (|E0|/w): "+str(A0)+"\n")
    f.write("Check ratio of 2pi|A0|/|B0|: "+str(2*np.pi*A0/B0)+"\n")
    f.write("|Bz| of light: "+str(Bz_max * ureg(field_units))+"\n")
    f.write("Range of input |E0| (E0i): "+str(E0i)+"\n")
    f.write("Degree of LG mode (p): "+str(p)+"\n")
    f.write("Order of LG mode (l): "+str(l)+"\n")
    f.write("Spin number (s): "+str(s)+"\n")
    f.write("Initial phase of time (phi0_t): "+str(phi0_t)+"\n")
    f.write("Initial azimuthal angle (phi0_xy): "+str(phi0_xy)+"\n")
    f.write("Polarization modulation (T/F): "+str(polarization_modulation)+"\n")
    f.write("output_file_head (string): "+output_file_head+"\n")
    f.write("[6] Critical E and B of SC\n")
    f.write("Quantum magnetic flux (Phi0 = h/2e): "+str(cons.h/2/cons.e * ureg('J/A').to('W/A*s'))+"\n")
    f.write("Hc1 of SC (Phi0/4pi/lambda^2*ln[lambda/xi]): "+str(Hc1)+"\n") # [ref] Gennes.P.D., pp.66, Eq (3-56)
    f.write("Hc2 of SC (Phi0/2pi xi^2): "+str(Hc2)+"\n")
    f.write("Hc of SC: "+str(Hc)+"\n")
    f.write("Bc1 of SC (mu0Hc1): "+str((mu_0*Hc1).to('T'))+"\n") # lower critical field
    f.write("Bc2 of SC (mu0Hc2): "+str((mu_0*Hc2).to('T'))+"\n") # upper critical field
    f.write("Bc of SC: "+str(Bc.to('T'))+"\n")
    f.write("Bc*2pi*w0^2/Phi0: "+str(mu_0*Hc*2*np.pi*(w0*ureg(length_units))**2/Phi0)+"\n")
    f.write("Bc2*2pi*w0^2/Phi0: "+str(mu_0*Hc2*2*np.pi*(w0*ureg(length_units))**2/Phi0)+"\n")
    f.write("Critical vector potential A0 (xi*Bc2): "+str(xi_coherent*Bc2)+"\n")
    f.write("Unit current density (J0 = 4*xi*Bc2/mu_0/lambdaL**2): "+str(4*xi_coherent*Bc2/mu_0/lambdaL**2)+"\n")
    f.write("|B0|/Bc: "+str(B0/((mu_0*Hc).to(field_units)))+"\n") # upper critical field
    f.write("|Bz|/Bc: "+str(Bz_max*ureg(field_units)/((mu_0*Hc).to(field_units)))+"\n") # upper critical field
    f.write("Fermi velocity: "+str(vF.to('m/s'))+"\n")
    f.write("Fermi velocity (unit of c): "+str(vF.to('m/s')/(speed_of_light))+"\n")
    f.write("Condensation energy (Bc**2/2/mu0): "+str(Econd.to('eV/'+length_units+'**3'))+"\n")
    f.write("[7] Others\n")
    f.write("Applied constant Bz: "+str(constant_Bz * ureg(field_units))+"\n")
    f.write("Solve time (unit of tau_0): "+str(solve_time)+"\n")
    f.write("Screen Set (T/F): "+str(screenSet)+"\n")
    f.close()

    ## Print and check
    f = open(file_name, "r")
    print(f.read())
    print('... Save to file: '+file_name)
    f.close()

    return tau, c


""" Example of EMwave_G_cir:
applied_vector_potential = EMwave_G_cir(w=1e8, E0=1, phi0=0)
"""

""" Example of A_LG:
E0i = 10
w_input = 2*np.pi
w0 = 0.1
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,0,0,0,0, False]       ## Linear polatization, Gauss:  for linear polarization, phi0_xy could be any number and s=0
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,0,1,0,np.pi/4, False] ## Circular polatization, Gauss: for Circular polarization, phi0_xy=pi/4 and s=+-1
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,0,0,0, False]       ## Linear polatization, LG01: for linear polarization, phi0_xy could be any number and s=0
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,1,0,np.pi/4, False] ## Circular polatization, LG01 (Radial + Azimuthal): for Circular polarization, phi0_xy=pi/4 and s=+-1
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,1,0,0, True]        ## Radial polatization, LG01: for Radial polarization, s=+1, phi0_xy=0, polarization_modulation = True
# p, l, s, phi0_t, phi0_xy, polarization_modulation = [0,1,1,0,np.pi/2, True]  ## Azimuthal platization, LG01: for Azimuthal polarization, s=+1, phi0_xy=np.pi/2, polarization_modulation = True
applied_vector_potential = A_LG(w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
"""

""" Example of A_LG_step:
E0i = 10
w_input = 2*np.pi
w0 = 0.1
Bz = 1
t_on, t_off = [0.0, 2.0]
applied_vector_potential = A_LG(w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             t_on=t_on, t_off=t_off, Bz=Bz, time_evolute=True,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, field_units=field_units,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
"""

""" Example of A2B(x, y, z, A)

applied_vector_potential_t = A_LG_t(x=x, y=y, z=z, t=t, w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             t_on=t_on, t_off=t_off, Bz=Bz, time_evolute=True,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, field_units=field_units,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
B = A2B(x, y, z, applied_vector_potential_t)
# Bx = B.x
# By = B.y
# Bz = B.z

E_LG_beam_t = E_LG_t(x=xv, y=yv, z=zv, t=t, w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             t_on=t_on, t_off=t_off, Bz=Bz_constant, time_evolute=True,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, field_units=field_units,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
applied_magnetic_field_t = E2Bv(xv,yv,E,Bz_constant,c,w)
# Bx = applied_magnetic_field_t[:,0]
# By = applied_magnetic_field_t[:,1]
# Bz = applied_magnetic_field_t[:,2]
"""

""" Test of avalability of function: (for the error of saving data)
# pickle.dumps(applied_vector_potential)
# np.dtype(applied_vector_potential)
# print(applied_vector_potential.dtype)
import pickle
import cloudpickle

applied_vector_potential2 = A_LG(w=1, w0=2, E0=3, phi0_t=4, phi0_xy=5, p=1, l=2, s=3, tau=1)

# np.void(cloudpickle.dumps(applied_vector_potential2))
applied_vector_potential2 = A_LG(w=w_input, w0=w0, E0=E0i,
                             phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c,
                             tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                             angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
# pickle.dumps(applied_vector_potential2)
cloudpickle.dumps(applied_vector_potential2)
"""

""" Select the parameters for optical states via "light_state_contral(keyword_of_state)":
options: 'lg00_l_x','lg00_l_y','lg00_c_l','lg00_c_r','lg01_l_x','lg01_l_y','lg01_c_c','lg01_c_r','lg01_c_a'
return p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head
"""

"""Example of Unit_check_save:
Unit_check_save(E0i,w0,w,light_source_type,length_units,E_field_units,angular_freq_units,subtitle)
"""

""" Example of MAKE_ANIMATIONS:
if MAKE_ANIMATIONS:
    test_video = make_video_from_solution(
        test_solution,
        quantities=["order_parameter", "phase", "scalar_potential","vorticity"],
        figsize=(22, 4),
    )
    display(test_video)
"""

# pip install cupy-cuda11x
# pip install cupy-cuda12x

""" Done."""

"""## Main scipts
The calculation of spatially- and temporally-resolved Generalized time-dependent GinzburgLandau (gTDGL) simulation. Deteails please refer Logan's paper [DOI: 10.1016/j.cpc.2023.108799].

### Part 1: Defining the device
Input the parameters for defining the SC thin film and constructing mesh for SC film.
<!-- Here we define a film with effective magnetic screening length $\Lambda=\lambda^2/d=(2\,\mu\mathrm{m})^2 / (0.05\,\mu\mathrm{m})=80\,\mu\mathrm{m}$, which is much larger than the dimensions of the sample. We therefore expect screening to be not important for this model. -->
"""

### Unit setting

import scipy.constants as cons
from pint import UnitRegistry
ureg = UnitRegistry()

length_units = "um" # SI: m
time_units = 'ps' # SI: s
current_units = "mA" # SI: A
mass_units = 'kg' # SI: kg
angular_freq_units = 'THz' # SI: 1/s # for demonstration
field_units = "mT" # SI: kg/s^2/A
E_field_units = "kvolt/meter" # newton per coulomb (N/C), or volt per meter (V/m), SI: kg*m^2/s^3/A


### SC properties

xi = 100/1000 # Coherent length
london_lambda = 100/1000 # London penetration depth

rate_eph = 4 # [meV], 40 meV calculated from tau_eph = 100fs for YBCO, https://journals.aps.org/prb/abstract/10.1103/PhysRevB.59.1497
gap_0 = 20 # [meV], 20 meV https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.65.801, https://arxiv.org/pdf/cond-mat/9910367.pdf
# gap ~ 1/0.57*Tc https://people.phys.ethz.ch/~ivanov/cmt/1314/ssth-lectureBC.pdf
# For the case of Niobium gap_0=2.3meV & rate_eph=11, gamma is ~0.4 => no vortex
# gamma = 2/rate_eph*gap_0
gamma = 10
u = 5.79

temperature = 0.5 # Unit of Tc
disorder_epsilon = 1/temperature-1

# Size of sample
height = 4
width = 6
thickness = 2/1000

# Conductivity of sample
resistivity = 150e-6 * ureg('ohm * cm')
condictivity = (1/resistivity).to('1 / ohm / '+length_units)

from tdgl.geometry import box
source = (
    tdgl.Polygon("source", points=box(1.1 * width, height / 100))
    .translate(dy=height / 2)
)
drain = source.scale(yfact=-1).set_name("drain")
#  Voltage measurement points
probe_points = [(2.8, 0.5), ( -2.8, 0.5)]


layer = tdgl.Layer(coherence_length=xi, london_lambda=london_lambda, thickness=thickness, gamma=gamma, u=u, conductivity=condictivity.magnitude)
film = tdgl.Polygon("film", points=tdgl.geometry.box(width, height, points=301))
device = tdgl.Device(
    "bar",
    layer=layer,
    film=film,
    terminals=[source, drain],
    length_units=length_units,
    probe_points=probe_points,
)

device.make_mesh(max_edge_length=xi / mesh_size, smooth=100)
fig, ax = device.plot(mesh=True, legend=False)
device.mesh_stats()

fluxoid_curves = [
    box(2, center=(-2.5, 0)),
    box(2, center=(2.5, 0)),
]

"""### Check Unit
This scipts is based on unitless gTDGL funtion. So this cell is for cheking unit based on the parameters.

"""

# PrintSet = True
PrintSet = False

## SC parameters
length_units = str(length_units)

if PrintSet: print('Length scale of sample')
mu_0 = cons.mu_0 * ureg('newton/A**2')
xi_coherent = xi * ureg(length_units)
if PrintSet: print('- Coherent length: {!s}'.format(xi_coherent))
lambdaL = london_lambda * ureg(length_units)
if PrintSet: print('- London penetration depth: {!s}'.format(lambdaL))
d_thickness = thickness * ureg(length_units)
lambdaL_eff = lambdaL**2/d_thickness
if PrintSet: print('- Effective London penetration depth (l^2/d): {!s}'.format(lambdaL_eff))
if PrintSet: print('- Thickness: {!s}'.format(d_thickness))
L_height = height * ureg(length_units)
L_width = width * ureg(length_units)
if PrintSet: print('- Height: {!s}'.format(L_height))
if PrintSet: print('- Width: {!s}'.format(L_width))
screen_length = lambdaL**2/d_thickness
if PrintSet: print('- Screen length: {!s}'.format(screen_length))

if PrintSet: print('Condictivitye of sample')
resistivity = 150e-6 * ureg('ohm * cm')
condictivity = 1/resistivity
if PrintSet: print('- Given resistivity: {!s}'.format(resistivity))
if PrintSet: print('- Given condictivity: {!s}'.format(condictivity))

if PrintSet: print('Gap of sample')
E_eph = rate_eph * ureg('meV')
E_gap_0 = gap_0 * ureg('meV')
F_gap_0 = gap_0*0.242 * ureg('THz')
if PrintSet: print('- Given inelastic coupling rate: {!s}'.format(E_eph))
if PrintSet: print('- Given SC gap energy: {!s}'.format(E_gap_0))
if PrintSet: print('- Given SC gap energy: {!s}'.format(F_gap_0))
if PrintSet: print('- Strength of inelastic scattering: {!s}'.format(gamma))


## Unit of Time

if PrintSet: print('Time scale of sample')
# tau_0 = 2 * ureg('s')# mu_0 * condictivity * lambdaL**2
tau_0 = mu_0 * condictivity * lambdaL**2
tau_0 = tau_0.to('s')
if PrintSet: print('- SC dissipation time (tau_0): {!s}'.format(tau_0.to(time_units)))
speed_of_light = cons.speed_of_light * ureg('m/s')
revised_speed_of_light = (speed_of_light*tau_0.to(time_units).magnitude)
if PrintSet: print('- Speed of light (unit of tau_0):  {!s}'.format(revised_speed_of_light.to('um/ps')))


## Angular frequency of 1 THz ( =2f)

if PrintSet: print('Given frequency of light')
w_Freq = (1/tau_0)
f_input = 1 * w_Freq
w_input = 2*np.pi * f_input
if PrintSet: print('- SC dissipation rate: {!s}'.format(w_Freq.to(angular_freq_units)))
if PrintSet: print('- Expected frequency of light: {!s}'.format(f_input.to(angular_freq_units)))
if PrintSet: print('- Expected angular frequency of light: {!s}'.format(w_input.to(angular_freq_units)))
w0 = ((speed_of_light/(f_input.to(angular_freq_units))).to('um'))
if PrintSet: print('- Wavelength estimation for w0: '+str(w0))
if PrintSet: print('- Useful ratio estimation w0/xi: '+str(w0/xi_coherent))
if PrintSet: print('- Useful ratio estimation xi/tau_GL: '+str(xi_coherent.to('um')/tau_0.to('ps')))
if PrintSet: print('- Useful ratio estimation w0/tau_LG: '+str(w0.to('um')/tau_0.to('ps')))


## Electrical field and Magnetic field Phi_0

if PrintSet: print('E and B of light')
c_rev = revised_speed_of_light.to(length_units+'/'+time_units).magnitude
B0_check = (1/(c_rev)) * ureg(field_units)#*tau_0.to(time_units).magnitude
A0_check = (1/2/np.pi) * ureg(f"{field_units} * {length_units}") # Suppose w_input = 2*pi
B0 = B0_check
E0 = B0 * speed_of_light
if PrintSet: print('- |E0| of light: {!s}'.format(E0.to(E_field_units)))
if PrintSet: print('- |B0| of light: {!s}'.format(B0.to(field_units)))
if PrintSet: print('- |B0| of inside the function: {!s}'.format(B0_check.to(field_units)))
if PrintSet: print('- |A0| of inside the function: {!s}'.format(A0_check.to(field_units+'*'+length_units)))
if PrintSet: print('- 2pi|A0|/|B0|=Wavelength defined inside the function: {!s}'.format((A0_check*2*np.pi/B0_check).to(length_units)))
    # superconducting flux quantum: Phi0 = h/2e
    # upper critical field: Bc2 = 0Hc2 = Phi0/2^2
if PrintSet: print('Critical E and B of SC')
Phi0 = cons.h/2/cons.e * ureg('J/A')
Hc1 = Phi0/4/np.pi/mu_0/lambdaL**2*np.log(lambdaL/xi_coherent) # [ref] Gennes.P.D., pp.66, Eq (3-56), but no mu_0
Hc2 = Phi0/2/np.pi/mu_0/xi_coherent**2 # [ref] Logan
Hc  = Hc1/(np.pi/np.sqrt(24)*xi_coherent/lambdaL*np.log(lambdaL/xi_coherent)) # [ref] Gennes.P.D., pp.66, Eq (3-56), but no mu_0
Bc1 = mu_0*Hc1
Bc2 = mu_0*Hc2
Bc  = mu_0*Hc
A0_critical = xi_coherent*Bc2
# Econd = (1/2)VN(0)2
# Econd = # [ref] Gennes.P.D., pp.66, Eq (3-41)
# Econd = Hc1**2/8/np.pi # [ref] Gennes.P.D., pp.66, Eq (3-1) # Gauss unit
Econd = Bc**2/2/mu_0
hbar = cons.hbar * ureg('J*s')
vF = np.pi*xi_coherent*E_gap_0/hbar # [ref] Gennes.P.D., pp.66, Eq (3-40)
if PrintSet: print('- Phi0: {!s}'.format(Phi0))
if PrintSet: print('- Hc1 of SC: {!s}'.format(Hc1))
if PrintSet: print('- Hc2 of SC: {!s}'.format(Hc2))
if PrintSet: print('- Bc1 of SC: {!s}'.format(Bc1.to('T')))
if PrintSet: print('- Bc2 of SC: {!s}'.format(Bc2.to('T')))
if PrintSet: print('- Critical vector potential A0: {!s}'.format(A0_critical.to('T*um')))
J0 = 4*xi_coherent*Bc2/mu_0/lambdaL**2
if PrintSet: print('- Unit current density: {!s}'.format(J0.to('A/um^2')))
if PrintSet: print('- Condensation energy (Bc**2/2/mu0): {!s}'.format(Econd.to('eV/'+length_units+'**3')))

""" Done!"""

"""### Setting of Laguerre-Gaussian Beam
Inputing the parameters for Laguerre-Gaussian Beam. <br>
!!! Impotent !!! this cell will clean up the files in filefolder @folder_name.
"""

### Make filefolder for saving ###

Parameter_set = {}

w0 = 0.75
quiver_scale = 4
xc_Gauss = 0
yc_Gauss = 0
gamma = 10
light_source_type = 'lg00_c_l'


### Parameter setting ###

w_input = np.copy(w_input_set)
case_name = 'I_'+str(int(current_amp*1000))+'_E_'+str(int(E0i*1000))
Parameter_set[case_name] = {'E0i':E0i,'light_source_type':light_source_type,'current_amp':current_amp}
screenSet = False
constant_Bz = 0

quiver_mesh_n = 20
# quiver_scale = 5
width_quiver = 0.1
dpi = 100
SC_solution_all = {}

""" Done ! """

"""### Part 2: Solve of device
Calculation and demonstration of gTDGL simtlation.
"""

# import cupy as cp
Execute_GPU = False

### Loop of calculation

# import tempfile
# tempdir = tempfile.TemporaryDirectory()
# tempdir = os.path.join(os.ugetcwd(),folder_name)
length_units = str(length_units)
print('Save')

# Set for snapshot
tn_set = [0,20,50,100,200,300]
# tn_set = [0,0.5,1,2,3,4,5,6]
# tn_set = [0,0.5,1]


for num_set in Parameter_set:

    E0i = np.copy(Parameter_set[num_set]['E0i'])
    light_source_type = str(Parameter_set[num_set]['light_source_type'])
    subtitle = '20250421_CPConfine_'+num_set+'_'
    newpath = r'/gpfs/sharedfs1/alb16177/vap24003/OutputData/20250421_Confine_CP_all/'+num_set

    terminal_currents=dict(source=current_amp, drain=-current_amp)

    ## Select the parameters for the states of light sourceu
    ## options: 'lg00_l_x','lg00_l_y','lg00_c_l','lg00_c_r','lg01_l_x','lg01_l_y','lg01_c_c','lg01_c_r','lg01_c_a'
    p, l, s, phi0_t, phi0_xy, polarization_modulation, output_file_head = light_state_contral(light_source_type)

    if not os.path.exists(newpath): os.makedirs(newpath)
    folder_name = newpath
    tempdir = newpath
    vedio_file_head = '_time'+str(solve_time)+'_SC_solution'+num_set
    options = tdgl.SolverOptions(
        solve_time=solve_time,
        field_units=field_units,
        current_units=current_units,
        include_screening=screenSet,
        screening_tolerance=5e-2,
        max_iterations_per_step=200000,
        screening_step_size=0.01,
        screening_step_drag=0.5,
        save_every=250,
        dt_max=5e-2,
        output_file=os.path.join(tempdir, output_file_head+vedio_file_head+".h5"),
        gpu=Execute_GPU,
        sparse_solver="pardiso",
    )

    ### Save and print

    def E_input_frame(Xv,Yv,ti,*,take_real: bool=True):
        Zv = np.zeros_like(Xv)
        Ex, Ey, Ez =  (E_LG_t(Xv, Yv, Zv, t=ti, w=w_input, w0=w0, E0=E0i, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
                                phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s,
                                tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                                t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute,
                                angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,))
        if take_real: return np.real(Ex)/E0i, np.real(Ey)/E0i
        else:         return Ex/E0i, Ey/E0i

    delete_files_in_directory(folder_name)
    fig_title0 = folder_name+'/'+subtitle+output_file_head
    X, Y, Xv, Yv, Zv = v_grid_generation(-width/2,width/2,-height/2,height/2,quiver_mesh_n)
    Bz_max = find_max_Bz(Xv,Yv,1,0,revised_speed_of_light.to('um/ps').magnitude,w_input)
    tau, c = Unit_check_save(E0i,w0,w_input,light_source_type,length_units,E_field_units,angular_freq_units,subtitle,solve_time,screenSet,folder_name,Bz_max)
    fig, ax = device.plot(mesh=True, legend=False)
    device.mesh_stats()
    plt.savefig(fig_title0+'_device.png')
    fig, ax = device.draw()
    plt.savefig(fig_title0+'_config.png')

    quiver_test = True
    if quiver_test:
            title_set = 'quiver test'
            E_x, E_y, E_z = (E_LG_t(Xv, Yv, Zv, t=4, w=w_input, w0=w0, E0=E0i, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
                                    phi0_t=0*np.pi/2, phi0_xy=phi0_xy, p=p, l=l, s=s,
                                    t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute,
                                    tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                                    angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,))
            B_x, B_y, B_z = E2Bv(Xv,Yv,E_x,E_y,constant_Bz,c,w_input)
            Bz_max = B_z
            plot_EM(X,Y,np.real(E_x),np.real(E_y),np.real(B_z),E0i=E0i,title=title_set,figsize=(9,3),scale=quiver_scale,dpi=dpi,width_quiver=width_quiver)
            print('Bz/Bc2 tatio:')
            # print(Bz_max/Bc2.to(field_units).magnitude)

    ### Solve device

    print('num_set: '+num_set)
    # if Execute_GPU:
    #       applied_vector_potential = A_LG_cupy(w=w_input, w0=w0, E0=E0i, phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c, tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
    #                              t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute, angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
    # else:
    applied_vector_potential = A_LG(w=w_input, w0=w0, E0=E0i, phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s, c=c, tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
                                t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute, angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,)
    SC_solution = tdgl.solve(device, options, applied_vector_potential=applied_vector_potential,disorder_epsilon=disorder_epsilon,terminal_currents=terminal_currents,)

     ### Plot the descrite time step of simulation

    plt.rcParams["figure.figsize"] = (3, 3)
    plt.figure()
    plt.plot(SC_solution.times,'.')
    fig_title = folder_name+'/'+subtitle+output_file_head+'_'+str(num_set)
    plt.savefig(fig_title+'_t.png')

    ### Demonstrate the electrical field, order parameter, vorticity, scalar potential from tn_set

    print(tn_set * tau_0.to('femtosecond'))

    for nt in range(len(tn_set)):
        ti = tn_set[nt]
        # title_set = label_set[nt]+' period (time:'+str(int(ti*100)/100)+' $\\tau_0$)'
        title_set = 'time:'+str(int(ti*100)/100)+' $\\tau_0$'
        E_x, E_y, E_z = (E_LG_t(Xv, Yv, Zv, t=ti, w=w_input, w0=w0, E0=E0i, xc_Gauss=xc_Gauss, yc_Gauss=yc_Gauss,
                                 phi0_t=phi0_t, phi0_xy=phi0_xy, p=p, l=l, s=s,
                                 t_on=t_on, t_off=t_off, Bz=constant_Bz, time_evolute=time_evolute,
                                 tau=tau_0.to(time_units).magnitude, polarization_modulation=polarization_modulation,
                                 angular_freq_units=angular_freq_units, length_units=length_units, E_field_units=E_field_units, time_units=time_units,))
        B_x, B_y, B_z = E2Bv(Xv,Yv,E_x,E_y,constant_Bz,c,w_input)
        plot_EM(X,Y,np.real(E_x),np.real(E_y),np.real(B_z),E0i=E0i,title=title_set,figsize=(9,3),scale=quiver_scale,dpi=dpi,width_quiver=width_quiver)
        plt.savefig(fig_title+'_'+str(nt)+'_E.png')

        SC_solution.solve_step = SC_solution.closest_solve_step(ti)
        # print('Step number: '+str(SC_solution.solve_step))
        fig, axes = SC_solution.plot_order_parameter(figsize=(10, 3),dpi=dpi)
        plt.savefig(fig_title+'_'+str(nt)+'_1.png')

        fig, axes = plt.subplots(1, 2, figsize=(9, 3),dpi=dpi)
        _ = SC_solution.plot_vorticity(ax=axes[0]) #, streamplot=False
        _ = SC_solution.plot_currents(ax=axes[1]) #, streamplot=False
        plt.savefig(fig_title+'_'+str(nt)+'_2.png')
    SC_solution_all.update({num_set:SC_solution})

    plt.rcParams['figure.figsize'] = [6, 10]
    fig, axes = SC_solution.dynamics.plot()
    # for ax in axes:
    #     ax.axvline(t0, color="k", alpha=0.5)
    plt.savefig(fig_title0+'_'+str(nt)+'_probe.png')

    ### Make video
    ### Excute "conda install -c conda-forge ffmpeg" at Anaconda

    if MAKE_ANIMATIONS:
        output_video = make_video_from_solution(
            SC_solution,
            quantities=["order_parameter", "phase","vorticity"],
            figsize=(18, 4),
            fps=20,
            dpi=100,
            quiver_scale=quiver_scale,
            quiver_mesh_n=quiver_mesh_n,
            output_file=fig_title+"_video.mp4",
        )

''' Done. '''

print('LG-TDGL Simulation done.')

